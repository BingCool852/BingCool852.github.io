<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>peakcool | 个人博客</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://peakcool.cn/</link>
    <atom:link href="http://peakcool.cn/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 28 Oct 2018 21:50:36 +0800</pubDate>
    <lastBuildDate>Sun, 28 Oct 2018 21:50:36 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Flutter Gradle Run Build Failed</title>
        <description>&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#flutter-gradle编译失败&quot;&gt;Flutter Gradle编译失败&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#错误日志&quot;&gt;错误日志&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#解决办法&quot;&gt;解决办法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;flutter-gradle编译失败&quot;&gt;Flutter Gradle编译失败&lt;/h2&gt;

&lt;h3 id=&quot;错误日志&quot;&gt;错误日志&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Launching lib/main.dart on Android SDK built for x86 in debug mode...
Initializing gradle...
Resolving dependencies...
* Error running Gradle:
Exit code 1 from: /Users/tangliangcheng/AndroidStudioProjects/flutter_app_demo01/android/gradlew app:properties:
Starting a Gradle Daemon (subsequent builds will be faster)

Project evaluation failed including an error in afterEvaluate {}. Run with --stacktrace for details of the afterEvaluate {} error.

FAILURE: Build failed with an exception.

* Where:
Build file '/Users/tangliangcheng/AndroidStudioProjects/flutter_app_demo01/android/app/build.gradle' line: 25

* What went wrong:
A problem occurred evaluating project ':app'.
&amp;gt; Could not resolve all files for configuration 'classpath'.
   &amp;gt; Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2).
     Searched in the following locations:
         https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 10s

Finished with error: Please review your Gradle project setup in the android/ folder.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;flutter⁩ ▸ ⁨packages⁩ ▸ ⁨flutter_tools⁩ ▸ ⁨gradle⁩&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;buildscript {
    repositories {
	google() //添加
        jcenter()
        maven {
            url 'https://dl.google.com/dl/android/maven2'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 28 Oct 2018 00:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/28/flutter-gradle-build.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/28/flutter-gradle-build.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>Cordova Android 扫码返回按钮路由返回上一级</title>
        <description>&lt;h2 id=&quot;cordova-android-扫码返回按钮路由回退&quot;&gt;Cordova Android 扫码返回按钮路由回退&lt;/h2&gt;

&lt;p&gt;最近在实现cordova 扫码需求时，用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;phonegap-plugin-barcodescanner&lt;/code&gt;库&lt;/p&gt;

&lt;p&gt;开启相机后，在android上，没有&lt;code class=&quot;highlighter-rouge&quot;&gt;取消扫码&lt;/code&gt;按钮，只能点击&lt;code class=&quot;highlighter-rouge&quot;&gt;返回&lt;/code&gt;按钮才能取消扫码&lt;/p&gt;

&lt;p&gt;这时会有一个问题，点击返回按钮时，webview路由会&lt;code class=&quot;highlighter-rouge&quot;&gt;go(-1)&lt;/code&gt;并且取消扫码关闭相机&lt;/p&gt;

&lt;p&gt;而实际期望的是关闭相机，路由不返回上一级&lt;/p&gt;

&lt;p&gt;在vue项目中解决思路是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. vuex中创建一个值 state.unBack = false作为临时保存扫码开启状态
2. 开启扫码时，设置 state.unBack = true
3. 在当前页路由勾子 beforeRouteLeave 中，判断unBack是否会false, false时正常路由行为， true时next(false)阻止路由跳转
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 17 Oct 2018 06:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/17/cordova-android-scanner.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/17/cordova-android-scanner.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 08 day</title>
        <description>&lt;h2 id=&quot;玩转进程&quot;&gt;玩转进程&lt;/h2&gt;

&lt;h3 id=&quot;多进程架构&quot;&gt;多进程架构&lt;/h3&gt;

&lt;h4 id=&quot;master-worker模式主从模式&quot;&gt;Master-Worker模式（主从模式）&lt;/h4&gt;

&lt;p&gt;图中进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或者管理工作进程，它是趋向稳定的。工作进程负责具体的业务处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/Master-Worder%E6%A8%A1%E5%BC%8F.png?raw=true&quot; alt=&quot;Master-Worker&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建子进程&quot;&gt;创建子进程&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;child_process&lt;/code&gt;模块提供了4个方法用于创建子进程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;spawn(): 启动一个子进程来执行命令&lt;/li&gt;
  &lt;li&gt;exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况&lt;/li&gt;
  &lt;li&gt;execFile(): 启动该一个子进程来执行可执行文件&lt;/li&gt;
  &lt;li&gt;fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的javascript文件模块即可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;spawn()与exec()、execFile()不同的是，后两者创建的时间可以指定&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4种方法的差别&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;回调/异常&lt;/th&gt;
      &lt;th&gt;进程类型&lt;/th&gt;
      &lt;th&gt;执行类型&lt;/th&gt;
      &lt;th&gt;可设置超时&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;spawn()&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
      &lt;td&gt;任意&lt;/td&gt;
      &lt;td&gt;命令&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;exec()&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
      &lt;td&gt;任意&lt;/td&gt;
      &lt;td&gt;命令&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;execFile()&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
      &lt;td&gt;任意&lt;/td&gt;
      &lt;td&gt;可执行文件&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fork()&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
      &lt;td&gt;Node&lt;/td&gt;
      &lt;td&gt;JavaScript文件&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;进程间通信&quot;&gt;进程间通信&lt;/h4&gt;

&lt;p&gt;主进程与工作线程之间通过&lt;code class=&quot;highlighter-rouge&quot;&gt;onmessage()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage()&lt;/code&gt;进行通信，子进程对象则由&lt;code class=&quot;highlighter-rouge&quot;&gt;send()&lt;/code&gt;方法实现主进程向子进程发送数据,&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件实现收听子进程发来的数据。&lt;/p&gt;

&lt;h4 id=&quot;进程间通信原理&quot;&gt;进程间通信原理&lt;/h4&gt;

&lt;p&gt;IPC的全称是Inter-Process Communication,即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并协调工作。实现进程间通信的结束有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道(pipe)技术。但是此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道( named pipe ) 实现， *nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法。&lt;/p&gt;

&lt;p&gt;父进程在实际创建子进程之前，会创建IPC通道去监听它，然后才真正创建出子进程，并通过环境变量(NODE_CHANNEL_FD)告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已经存在的IPC通道，从而完成父子进程之间的连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IPC创建和实现示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/IPC%E5%88%9B%E5%BB%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;IPC创建和实现示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建IPC管道的步骤示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E5%88%9B%E5%BB%BAIPC%E7%AE%A1%E9%81%93%E7%9A%84%E6%AD%A5%E9%AA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：只有启动的子进程是Node进程时&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;句柄传递&quot;&gt;句柄传递&lt;/h4&gt;

&lt;p&gt;只有一个进程可以监听到一个端口上，其余的进程在监听的过程中都会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;EADDRINUSE&lt;/code&gt;异常，这是端口被占用的情况，新的进程不能继续监听该端口。这个问题破坏我们将多个进程监听同一个端口的想法。要解决这个问题，通常的做法是让每个进程监听不同的端口，其中主进程监听主端口（如80），主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口进程上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E4%B8%BB%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6%E3%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;主进程接收、分配网络请求示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上适当的负载均衡，使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程中需要用掉2个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了系统的扩展能力。&lt;/p&gt;

&lt;p&gt;为了解决上述这样的问题，Node在版本v0.5.9引入了进程间发送句柄的功能。send()方法除了能通过IPC发送数据外，还能发送句柄，第二个可选参数就是句柄，如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sendHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;什么是句柄呢？&lt;strong&gt;句柄是一种可以用来标识资源的引用&lt;/strong&gt;，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象，一个客户端socket对象、一个UDP套接字、一个管道等。&lt;/p&gt;

&lt;p&gt;发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程间建立新的socket连接来转发数据。文件描述符浪费的问题可以通过这种方式轻松解决。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%B0%86%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E7%BB%99%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%202.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主进程代码:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'child_process'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'child.js'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'net'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'handle by parent'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1337&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'server'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子进程代码:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'message'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'server'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'handle by child'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再优化，将服务器句柄发送给子进程之后，关闭服务器监听，让子进程处理请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E5%8F%A5%E6%9F%84%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E8%BF%98%E5%8E%9F%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;句柄的发送与还原示意图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;句柄发送与还原&quot;&gt;句柄发送与还原&lt;/h4&gt;

&lt;p&gt;目前子进程对象send()方法可以发送的句柄类型包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;net.Socket TCP套接字&lt;/li&gt;
  &lt;li&gt;net.Server TCP服务器&lt;/li&gt;
  &lt;li&gt;net.Navtive C++层面的TCP套接字或者IPC管道&lt;/li&gt;
  &lt;li&gt;dgram.Socket UDP套接字&lt;/li&gt;
  &lt;li&gt;dgram.Native C++层面的UDP套接字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;，另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;参数如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'NODE_HANDLE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'net.Server'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;发送到IPC管道中的实际是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。&lt;/p&gt;

&lt;p&gt;多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用，换言之就是网络请求向服务器端发送请求时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是&lt;strong&gt;抢占式&lt;/strong&gt;的。&lt;/p&gt;

&lt;h3 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h3&gt;

&lt;p&gt;在进程间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来。&lt;/p&gt;

&lt;p&gt;比如：饭店将客人的点单分发给多个厨师进行点餐点制作。既然涉及多个厨师共同处理所有菜单，那么保证每个厨师的工作量是一门学问，既不能让一些厨师忙不过来，也不能让一些厨师闲着，这个保证多个处理单元工作量公平的策略叫做&lt;strong&gt;负载均衡&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Node默认提供的机制是&lt;strong&gt;抢占式&lt;/strong&gt;策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。&lt;/p&gt;

&lt;p&gt;为此Node在v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫做&lt;strong&gt;Round-Robin 伦叫调度&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 06:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/11/learn-node-08-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/11/learn-node-08-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 07 day</title>
        <description>&lt;h2 id=&quot;构建web应用&quot;&gt;构建Web应用&lt;/h2&gt;

&lt;p&gt;从http模块中服务器端的&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;事件开始分析。&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;事件发生于网络连接的建立，客户端向服务器端发送报文，服务器端解析报文，发送HTTP请求的报头时.&lt;/p&gt;

&lt;p&gt;在具体的业务中，一般会有如下需求:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求方法的判断&lt;/li&gt;
  &lt;li&gt;URL的路径解析&lt;/li&gt;
  &lt;li&gt;URL中查询字符串解析&lt;/li&gt;
  &lt;li&gt;Cookie的解析&lt;/li&gt;
  &lt;li&gt;Basic认证&lt;/li&gt;
  &lt;li&gt;表单数据的解析&lt;/li&gt;
  &lt;li&gt;任意格式文件的上传处理&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cookie&quot;&gt;Cookie&lt;/h3&gt;

&lt;p&gt;Cookie的处理分为如下几步:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器向客户端发送Cookie&lt;/li&gt;
  &lt;li&gt;浏览器将Cookie保存&lt;/li&gt;
  &lt;li&gt;之后每次刷新浏览器都会将Cookie发向服务器端&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cookie参数&quot;&gt;Cookie参数&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器不发送这个Cookie&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Max-Age&lt;/code&gt;是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中保存，下次打开浏览器依然有效。&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时过期。&lt;code class=&quot;highlighter-rouge&quot;&gt;Max-Age&lt;/code&gt;则告知浏览器多久后过期，当两个值同时存在时，且同时被支持时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Max-Age&lt;/code&gt;会覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HttpOnly&lt;/code&gt;告知浏览器不允许通过脚本&lt;code class=&quot;highlighter-rouge&quot;&gt;document.cookie&lt;/code&gt;去更改这个Cookie值，事实上，设置&lt;code class=&quot;highlighter-rouge&quot;&gt;HttpOnly&lt;/code&gt;之后，这个值在&lt;code class=&quot;highlighter-rouge&quot;&gt;document.cookie&lt;/code&gt;中不可见，但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Secure&lt;/code&gt; 当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，很难被窃听到&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cookie的性能影响&quot;&gt;Cookie的性能影响&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;减少Cookie的大小&lt;/li&gt;
  &lt;li&gt;为静态组件使用不同的域名&lt;/li&gt;
  &lt;li&gt;减少DNS查询&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;session&quot;&gt;Session&lt;/h3&gt;

&lt;h4 id=&quot;session与内存&quot;&gt;Session与内存&lt;/h4&gt;

&lt;p&gt;为了解决性能问题和&lt;code class=&quot;highlighter-rouge&quot;&gt;Session&lt;/code&gt;数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是&lt;code class=&quot;highlighter-rouge&quot;&gt;redies&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;memcached&lt;/code&gt;等。通过这些高效的缓存，node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都迎刃而解&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;session与安全&quot;&gt;Session与安全&lt;/h4&gt;

&lt;p&gt;典型的&lt;code class=&quot;highlighter-rouge&quot;&gt;XXS&lt;/code&gt;(跨站脚本攻击 Cross Site Scripting)拿到用户口令，实现伪造，通常都是由网站开发者决定哪些脚本可以执行在浏览器端，不过&lt;code class=&quot;highlighter-rouge&quot;&gt;XXS&lt;/code&gt;漏洞会让别的脚本执行。它的主要形成原因多数是用户的输入没有被转义，而被直接执行。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;缓存&quot;&gt;缓存&lt;/h3&gt;

&lt;h4 id=&quot;使用缓存流程图&quot;&gt;使用缓存流程图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80web%E5%BA%94%E7%94%A8/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;使用缓存流程图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;缓存设置&quot;&gt;缓存设置&lt;/h4&gt;

&lt;h4 id=&quot;清除缓存&quot;&gt;清除缓存&lt;/h4&gt;

&lt;p&gt;知晓了如何设置缓存，以达到节省网络带宽的目的，但是缓存一旦设定，当服务器端意外更新内容时，却无法通知客户端更新。这使得我们在使用缓存时也要为其设定版本号，所幸浏览器根据URL进行缓存，那么一旦内容更新时，我们就让浏览器发起新的url请求，使新内容能够被客户端更新。一般的更新机制有如下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次发布，路径中跟随web应用的版本号： http://url.com/?v=20170801&lt;/li&gt;
  &lt;li&gt;每次发布，路径中跟随该文件内容的hash值： http://url.com/?hash=afadsad11sad&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说根据文件内容的hash值进行缓存淘汰更加高效，因为文件内容不一定跟随web应用的版本而更新，而内容没有更新时，版本号的改动导致更新毫无意义，因此以文件内容形成的hash值更精确&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;数据上传&quot;&gt;数据上传&lt;/h3&gt;

&lt;p&gt;Node的http模块只对HTTP报文的头部进行了解析，然后触发request事件。如果请求中还带有内部部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。通过设置报头的&lt;code class=&quot;highlighter-rouge&quot;&gt;Transfer-Encoding&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;即可判断请求中是否带有内容。&lt;/p&gt;

&lt;h4 id=&quot;表单数据&quot;&gt;表单数据&lt;/h4&gt;

&lt;p&gt;默认的表单提交，请求头中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;字段值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;其他格式&quot;&gt;其他格式&lt;/h4&gt;

&lt;p&gt;常见的提交还有JSON和XML文件等，判断和解析他们的原理都比较相似，都是依据&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;的值决定，其中JSON类型的值为application/json,XML的值为application/xml&lt;/p&gt;

&lt;p&gt;需要注意的是，在Content-Type中可能还会附带&lt;code class=&quot;highlighter-rouge&quot;&gt;charset=utf-8&lt;/code&gt;的编码信息。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;中间件与性能&quot;&gt;中间件与性能&lt;/h3&gt;

&lt;h4 id=&quot;中间件的工作模型&quot;&gt;中间件的工作模型&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80web%E5%BA%94%E7%94%A8/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.png?raw=true&quot; alt=&quot;中间件的工作模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要能提升性能的点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编写高效的中间件
  提升单个中间件的处理速度，以尽早调用next()执行后续逻辑。需要知道的是，一旦中间件被匹配，那么每个请求都会使该中间件执行一次，哪怕它只浪费了1毫秒的执行时间都会让我们QPS显著下降，常见的优化方法有几种。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;使用高效的方法，必要时通过jsperf.com测试基准性能&lt;/li&gt;
      &lt;li&gt;缓存需要重复计算的接口&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理利用路由，避免不必要的中间件执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;页面渲染&quot;&gt;页面渲染&lt;/h2&gt;

&lt;h3 id=&quot;mime&quot;&gt;MIME&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MIME&lt;/code&gt;的全称是&lt;code class=&quot;highlighter-rouge&quot;&gt;Multipurpose Internet Mail Extensions&lt;/code&gt;,从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;MIME&lt;/code&gt;值，如JSON文件的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/json&lt;/code&gt;，XML文件的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/xml&lt;/code&gt;，PDF文件的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/pdf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Node社区中&lt;code class=&quot;highlighter-rouge&quot;&gt;mime&lt;/code&gt;模块可以判断文件类型。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mime'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/path/to/file.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/plain'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'file.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/plain'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.TXT'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/plain'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/html'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Disposition&lt;/code&gt;: 无论响应的内容是什么样的&lt;code class=&quot;highlighter-rouge&quot;&gt;MIME&lt;/code&gt;值，不要求客户端去打开它，只需弹出并下载它。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Aug 2017 05:03:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/06/learn-node-07-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/06/learn-node-07-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 06 day</title>
        <description>&lt;h3 id=&quot;构建tcp服务&quot;&gt;构建TCP服务&lt;/h3&gt;

&lt;h4 id=&quot;tcp&quot;&gt;TCP&lt;/h4&gt;

&lt;p&gt;全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链路层、网络传输层、会话层、表示层、应用层）中属于传输层协议。&lt;/p&gt;

&lt;p&gt;其最显著的特征是在传输之间需要3次握手形成会话，只有会话形成之后，服务器端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个&lt;code class=&quot;highlighter-rouge&quot;&gt;套接字&lt;/code&gt;，这两个套接字共同形成一个链接。服务器端与客户端则通过套接字实现两者之间链接的操作。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;net&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'net'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Hello'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'end'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'连接断开'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8124&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'server bound'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//成功&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;tcp服务的事件&quot;&gt;TCP服务的事件&lt;/h4&gt;

&lt;p&gt;在上述示例中，代码分为服务器事件和连接事件。&lt;/p&gt;

&lt;h5 id=&quot;服务器事件&quot;&gt;服务器事件&lt;/h5&gt;
&lt;p&gt;对于通过&lt;code class=&quot;highlighter-rouge&quot;&gt;net.createServer()&lt;/code&gt;创建的服务器，它是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EventEmitter&lt;/code&gt;实例，它自定义事件有如下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;listening: 在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;server.listen()&lt;/code&gt;绑定端口或者Domain Socket后触发，简洁写法为&lt;code class=&quot;highlighter-rouge&quot;&gt;server.list(port, listeningListener)&lt;/code&gt;，通过第二个参数传入。&lt;/li&gt;
  &lt;li&gt;connection: 每个客户端套接字连接到服务器端时触发，简洁写法为&lt;code class=&quot;highlighter-rouge&quot;&gt;net.createServer()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;close: 当服务器关闭时触发，在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;server.close()&lt;/code&gt;后，服务器将停止接受新的套接字连接，但保持当前连接，等所有连接断开后会触发该事件。&lt;/li&gt;
  &lt;li&gt;error: 当服务器发生异常时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连接事件&quot;&gt;连接事件&lt;/h5&gt;

&lt;p&gt;服务器可以同时与多个客户端保持连接，对于每个连接而言就是典型的可写可读&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;对象可以用于服务器端和客户端之间的通信，既可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;事件从一端读取另一端发来的数据，也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;方法从一端向另外一端发送数据。具有如下自定义事件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data: 当一端调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;发送数据时，另一端会触发&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;事件，事件传递的数据即是&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;发送的数据。(&lt;strong&gt;注意:&lt;/strong&gt;并不是每次write都会触发一次data事件,当关闭&lt;code class=&quot;highlighter-rouge&quot;&gt;Nagle&lt;/code&gt;算法后，另一端可能收到多个小数据包合并，只触发一次data事件)&lt;/li&gt;
  &lt;li&gt;end: 当连接中的任意一端发送了FIN数据时，将会触发该事件。&lt;/li&gt;
  &lt;li&gt;connect: 该事件用于客户端，当套接字与服务器端连接成功时会被触发。&lt;/li&gt;
  &lt;li&gt;drain: 当任意一端调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;发送数据时，当前这端会触发该事件。&lt;/li&gt;
  &lt;li&gt;error: 当异常发生时，触发该事件。&lt;/li&gt;
  &lt;li&gt;close: 当套接字完全关闭时，触发该事件。&lt;/li&gt;
  &lt;li&gt;timeout: 当一定事件后连接不再活跃时，该事件将会被触发，通知用户当前连接已经被闲置了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;TCP套接字是可写可读的Stream对象，可以利用pip()方法巧妙实现管道操作&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;udp&quot;&gt;UDP&lt;/h3&gt;

&lt;p&gt;在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下，存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如：音频、视频等等。DNS服务也是基于它实现的。&lt;/p&gt;

&lt;h4 id=&quot;创建udp套接字&quot;&gt;创建UDP套接字&lt;/h4&gt;

&lt;p&gt;一旦创建，既可以作为客户端发送数据，也可以作为服务器端接受数据。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dgram&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'dgram'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dgram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createScoket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'udp4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建服务器端：调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dgram.bing(port, [address])&lt;/code&gt; 设置网卡和端口&lt;/li&gt;
  &lt;li&gt;创建客户端，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;send()&lt;/code&gt;发送消息到网络中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;udp套接字事件&quot;&gt;UDP套接字事件&lt;/h4&gt;

&lt;p&gt;UDP套接字事件只是一个EventEmitter的实例，具备如下自定义事件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;message: 当UDP套接字侦听网卡端口后，接受到消息时触发该事件，触发携带的数据为消息的&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;对象和一个远程地址信息&lt;/li&gt;
  &lt;li&gt;listening: 当UDP套接字开始侦听时触发&lt;/li&gt;
  &lt;li&gt;close: 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt;方法时触发该事件，并不再触发&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件。如需再次触发&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件，可以重新绑定&lt;/li&gt;
  &lt;li&gt;error: 当异常发生时触发&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;构建http服务&quot;&gt;构建HTTP服务&lt;/h3&gt;

&lt;h4 id=&quot;http&quot;&gt;HTTP&lt;/h4&gt;

&lt;p&gt;从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。&lt;/p&gt;

&lt;p&gt;无论是HTTP请求报文还是HTTP响应报文，报文内容都包含两个部分：报文头和报文体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、TCP的3次握手&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Rebuilt URL to: www.baidu.com/
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;   Trying 220.181.111.188...
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; TCP_NODELAY &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Connected to www.baidu.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;220.181.111.188&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; port 80 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#0)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、客户端想服务器端发送请求报文&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; GET / HTTP/1.1
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Host: www.baidu.com
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; User-Agent: curl/7.54.0
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Accept: &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、服务器端完成处理后，向客户端发送响应内容，包括响应头和响应体&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: bfe/1.0.8.18
&amp;lt; Date: Thu, 03 Aug 2017 05:20:56 GMT
&amp;lt; Content-Type: text/html
&amp;lt; Content-Length: 2381
&amp;lt; Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT
&amp;lt; Connection: Keep-Alive
&amp;lt; ETag: &lt;span class=&quot;s2&quot;&gt;&quot;588604c8-94d&quot;&lt;/span&gt;
&amp;lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
&amp;lt; Pragma: no-cache
&amp;lt; Set-Cookie: &lt;span class=&quot;nv&quot;&gt;BDORZ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;27315&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; max-age&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;86400&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;.baidu.com&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/
&amp;lt; Accept-Ranges: bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、最后部分为结束会话的信息&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;http模块&quot;&gt;http模块&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;http模块即是将&lt;code class=&quot;highlighter-rouge&quot;&gt;connection&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;的过程进行了封装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%60connection%60%E5%88%B0%60request%60%E7%9A%84%E8%BF%87%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85.png?raw=true&quot; alt=&quot;`connection`到`request`的过程进行封装&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除此之外，http模块将连接所用套接字的读写抽象为&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerRequest&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerResponse&lt;/code&gt;对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块&lt;code class=&quot;highlighter-rouge&quot;&gt;http_parser&lt;/code&gt;进行解析，解析完请求报文的报头后，触发&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;事件，调用用户业务逻辑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/http%E6%A8%A1%E5%9D%97%E4%BA%A7%E7%94%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true&quot; alt=&quot;http模块产生请求的流程&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;http请求&quot;&gt;http请求&lt;/h5&gt;

&lt;p&gt;请求报文头第一行&lt;code class=&quot;highlighter-rouge&quot;&gt;GET/HTTP/1.1&lt;/code&gt;解析分为如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;req.method属性： 值为GET,是为http请求方法&lt;/li&gt;
  &lt;li&gt;req.url属性：值为/&lt;/li&gt;
  &lt;li&gt;req.httpVersion属性，值为1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余报头很规律的&lt;code class=&quot;highlighter-rouge&quot;&gt;Key: Value&lt;/code&gt;格式，被解析后放置在&lt;code class=&quot;highlighter-rouge&quot;&gt;req.headers&lt;/code&gt;属性上传递给业务逻辑调用。
报文体部分则抽象为一个只读对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能操作。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;trunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;trunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'end'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Hello World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;http响应&quot;&gt;http响应&lt;/h5&gt;

&lt;p&gt;http响应封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部消息的API为&lt;code class=&quot;highlighter-rouge&quot;&gt;setHeader()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;writeHead()&lt;/code&gt;两个步骤，实际生成如下报文：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setHeader&lt;/code&gt;进行多次设置，但只有调用&lt;code class=&quot;highlighter-rouge&quot;&gt;writeHead&lt;/code&gt;后，报头才会被写入到连接中。
报文体部分则是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;res.write()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;res.end()&lt;/code&gt;方法实现，后者和前者的差别在于&lt;code class=&quot;highlighter-rouge&quot;&gt;res.end()&lt;/code&gt;会先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;发送数据，然后发送信号告知服务器这次响应结束。&lt;/p&gt;

&lt;h5 id=&quot;http服务的事件&quot;&gt;http服务的事件&lt;/h5&gt;

&lt;p&gt;服务器也是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EventEmitter&lt;/code&gt;实例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;connection事件&lt;/li&gt;
  &lt;li&gt;request事件&lt;/li&gt;
  &lt;li&gt;close事件&lt;/li&gt;
  &lt;li&gt;checkContinue事件&lt;/li&gt;
  &lt;li&gt;connect事件&lt;/li&gt;
  &lt;li&gt;upgrade事件&lt;/li&gt;
  &lt;li&gt;clientError事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http客户端&quot;&gt;http客户端&lt;/h4&gt;

&lt;p&gt;与http服务器基本相似，提供一个&lt;code class=&quot;highlighter-rouge&quot;&gt;http.request(options, connect)&lt;/code&gt; 用于构造HTTP客户端。&lt;/p&gt;

&lt;h5 id=&quot;options选项&quot;&gt;options选项&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;host: 服务器的域名或者IP地址, 默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;hostname: 服务器名称&lt;/li&gt;
  &lt;li&gt;port: 服务器端口&lt;/li&gt;
  &lt;li&gt;localAddress: 建立网络连接的本地网卡&lt;/li&gt;
  &lt;li&gt;socketPath: Domain套接字路径&lt;/li&gt;
  &lt;li&gt;method: HTTP请求方法，默认为GET&lt;/li&gt;
  &lt;li&gt;path: 请求路径，默认为/&lt;/li&gt;
  &lt;li&gt;headers: 请求头对象&lt;/li&gt;
  &lt;li&gt;auth: &lt;code class=&quot;highlighter-rouge&quot;&gt;Basic&lt;/code&gt;认证，这个值将被计算为请求头中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization&lt;/code&gt;部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;http响应-1&quot;&gt;http响应&lt;/h5&gt;

&lt;p&gt;HTTP客户端的响应对象与服务器相似，在&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRequest&lt;/code&gt;对象中，它的事件叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;http代理&quot;&gt;http代理&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;HTTP代理对服务器端创建的连接进行管理&lt;/strong&gt;
&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/HTTP%E4%BB%A3%E7%90%86%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86.png?raw=true&quot; alt=&quot;HTTP代理对服务器端创建的连接进行管理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名下有下载连接数的限制是相同的行为。如需改变，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;option&lt;/code&gt;中传递&lt;code class=&quot;highlighter-rouge&quot;&gt;agent&lt;/code&gt;选项。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;构建webscoket服务&quot;&gt;构建WebScoket服务&lt;/h3&gt;

&lt;p&gt;WebScoket与传统HTTP有以下好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端与服务器端只建立一个TCP连接，可以使用更少的连接&lt;/li&gt;
  &lt;li&gt;WebScoket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活高效&lt;/li&gt;
  &lt;li&gt;有更轻量的协议头，减少数据传输&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebScoket协议主要分为两个部分：&lt;strong&gt;握手&lt;/strong&gt; 和 &lt;strong&gt;数据传输&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;网络服务与安全&quot;&gt;网络服务与安全&lt;/h3&gt;

&lt;p&gt;SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传输到应用层之前就已经完成了加密和解密的过程。最初的SSL应用在web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称为TLS(Transport Layer Security, 安全传输层协议)。&lt;/p&gt;

&lt;h4 id=&quot;tlsssl&quot;&gt;TLS/SSL&lt;/h4&gt;

&lt;p&gt;TLS/SSL是一个公钥/私钥的结构，是一个非堆成的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接受到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以建立连接安全传输之前，客户端和服务器端互换公钥。客户端发送数据时要通过服务器端的公钥加密，服务器端发送数据时则需要通过客户端的公钥进行加密。&lt;/p&gt;

&lt;p&gt;Node底层采用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;openssl&lt;/code&gt;实现的TLS/SSL,为此要生成公钥和私钥可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;openssl&lt;/code&gt;实现。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 服务器端私钥
openssl genrsa &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; server.key 1024

// 客户端私钥
openssl genrsa &lt;span class=&quot;nt&quot;&gt;--out&lt;/span&gt; client.key 1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是这样网络中依然可能存在窃听情况，典型的例子是中间人攻击。为了解决这个问题，引入了&lt;strong&gt;数字证书&lt;/strong&gt;。与直接公钥不同，数字证书中包含了服务器的名称和主机名，服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。&lt;/p&gt;

&lt;h4 id=&quot;https&quot;&gt;HTTPS&lt;/h4&gt;

&lt;p&gt;HTTPS服务就是工作在TLS/SSL上的HTTP。&lt;/p&gt;

&lt;p&gt;创建HTTPS服务如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;准备证书&lt;/li&gt;
  &lt;li&gt;创建HTTPS服务&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 02 Aug 2017 07:37:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/02/learn-node-06-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/02/learn-node-06-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 05 day</title>
        <description>&lt;h2 id=&quot;理解buffer&quot;&gt;理解Buffer&lt;/h2&gt;

&lt;h3 id=&quot;buffer对象&quot;&gt;Buffer对象&lt;/h3&gt;

&lt;p&gt;Buffer是一个像Array的对象，但它主要用于操作字节。
Buffer所占用的内存不是通过v8分配的，属于堆外内存。&lt;/p&gt;

&lt;p&gt;在编码中，中文字在uft-8编码下占3各元素，字母和半角标点符号占用1个元素。&lt;/p&gt;

&lt;h3 id=&quot;buffer内存分配&quot;&gt;Buffer内存分配&lt;/h3&gt;

&lt;p&gt;为了高效地使用申请来的内存，node采用了slab分配机制。slab是一种动态内存管理机制，最早诞生于SunOS操作系统中，目前在一些*nix操作系统中有广泛应用。slab就是申请一块申请好的固定大小的内存区域。&lt;/p&gt;

&lt;p&gt;slab三种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;full: 完全分配状态&lt;/li&gt;
  &lt;li&gt;partial: 部分分配状态&lt;/li&gt;
  &lt;li&gt;empty: 没有被分配状态&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;size 小于8kb即为小对象，大于为大对象。&lt;/p&gt;

&lt;h4 id=&quot;分配小buffer对象&quot;&gt;分配小Buffer对象&lt;/h4&gt;

&lt;p&gt;同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8kb空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是9kb的内存没有释放。&lt;/p&gt;

&lt;h4 id=&quot;分配大buffer对象&quot;&gt;分配大Buffer对象&lt;/h4&gt;

&lt;p&gt;如果需要超过8kb的Buffer对象，将会直接分配一个&lt;code class=&quot;highlighter-rouge&quot;&gt;SlowBuffer&lt;/code&gt;对象作为slab单元，这个slab单元将会被这个大Buffer对象独占。&lt;/p&gt;

&lt;h3 id=&quot;buffer的转换&quot;&gt;Buffer的转换&lt;/h3&gt;

&lt;p&gt;Buffer对象可以与字符串之间相互转换，目前支持类型如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ASCII&lt;/li&gt;
  &lt;li&gt;UTF-8&lt;/li&gt;
  &lt;li&gt;UTD-16LE/UCS-2&lt;/li&gt;
  &lt;li&gt;Base64&lt;/li&gt;
  &lt;li&gt;Binary&lt;/li&gt;
  &lt;li&gt;Hex&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//判断编码是否支持&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;字符串转buffer&quot;&gt;字符串转Buffer&lt;/h4&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个Buffer对象可以存储不同的编码类型的字符串转码的值，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;方法可以实现。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;由于可以不断写入内容到Buffer对象中并且每次写入可以指定编码，所以Buffer对象中可以存在多种编码转化后的内容。值得注意的是，每种编码所用的字节长度不一样，将Buffer反转回字符串时需要小心处理。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;buffer转字符串&quot;&gt;Buffer转字符串&lt;/h4&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//encoding默认为UTF-8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;buffer的拼接&quot;&gt;Buffer的拼接&lt;/h3&gt;

&lt;p&gt;Buffer的使用场景通常是以一段一段的方式传输。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这句代码隐藏了toString()操作，等价于:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样的方式在英文环境下不错有问题，但对于宽字节的中文就会出现乱字节问题。&lt;/p&gt;

&lt;h3 id=&quot;buffer与性能&quot;&gt;Buffer与性能&lt;/h3&gt;

&lt;p&gt;Buffer在文件I/O和网络I/O中运用广泛，尤其在网络传输中。在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为Buffer，以二进制数据传输。&lt;/p&gt;

&lt;p&gt;在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Aug 2017 07:13:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/01/learn-node-05-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/01/learn-node-05-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 04 day</title>
        <description>&lt;h2 id=&quot;内存控制&quot;&gt;内存控制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;问题1：Node如何利用CPU和I/O这两个服务器资源？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题2：Node如何合理高效地是用内存?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一切都与Node的JavaScript执行引擎V8息息相关&lt;/p&gt;

&lt;h3 id=&quot;v8的内存限制&quot;&gt;V8的内存限制&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;64位系统下约为1.4GB&lt;/li&gt;
  &lt;li&gt;32位系统下约为0.7GB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么V8要限制堆的大小呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表层原因因为V8最初为浏览器而设计，不大可能遇到大量是用内存的场景。对于网页来说，V8的限制值已经足以应付。&lt;/li&gt;
  &lt;li&gt;深层的原因是V8的垃圾回收机制的限制。按照官方的说法，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至需要1秒以上。这是垃圾回收中引起的JavaScript线程暂停执行的时间，在这样的时间开销下，应用的性能和响应能力会直线下降。这样的情况不仅后端服务器无法接受，前端浏览器也无法接收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;v8的垃圾回收机制&quot;&gt;V8的垃圾回收机制&lt;/h3&gt;

&lt;h4 id=&quot;内存分代回收算法&quot;&gt;内存分代回收算法&lt;/h4&gt;

&lt;p&gt;在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/V8%E5%88%86%E4%BB%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;分代&quot; /&gt;&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h4 id=&quot;新生代scavenge算法&quot;&gt;新生代：Scavenge算法&lt;/h4&gt;

&lt;p&gt;新生代中主要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;算法进行垃圾回收。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;算法实现中主要采用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Cheney&lt;/code&gt;算法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为&lt;code class=&quot;highlighter-rouge&quot;&gt;semispace&lt;/code&gt;。在这两个&lt;code class=&quot;highlighter-rouge&quot;&gt;semispace&lt;/code&gt;空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;semispace&lt;/code&gt;空间称为&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间，处于闲置状态的称为&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间。当我们分配对象时，先是在&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间中进行分配。当开始进行垃圾回收时，会检查&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间中存活的对象，这些存活的对象将被复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间中，而非存活对象占用的空间将会被释放。完成复制后，&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间和&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间进行互换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;缺点是只能使用堆内存的一般，这是由划分空间和复制机制所决定的。但是Scavenge只复制存活的对象，并且对于声明周期短的场景存活对象占很少部分，所以他在时间效率上有优异的表现，它是典型的牺牲空间换取时间的算法。所以在新生代中尤为合适。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/V8%E5%A0%86%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;新生代堆内存&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;当一个对象经过多次复制依然存户时，它将被认为是生命周期较长的对象。较长生命周期的对象随后会被移到老生代中，采用新的算法进行管理，这一过程称为&lt;code class=&quot;highlighter-rouge&quot;&gt;晋升&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;晋升条件主要有两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否经历过&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;回收&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间的内存占用比超过限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;老生代-mark-sweep--mark-compact算法&quot;&gt;老生代： Mark-Sweep &amp;amp; Mark-Compact算法&lt;/h4&gt;

&lt;p&gt;Mark-Sweep: 标记清除算法，它分为标记和清除两个阶段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/Mark-Sweep%E5%9C%A8%E8%80%81%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%A0%87%E8%AE%B0%E5%90%8E%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;Mark-Sweep&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Mark-Sweep&lt;/code&gt;会有一个最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态，碎片化。这时如果分配一个大对象时可能所有的碎片空间无法完成，就会提前触发垃圾回收机制，而这次回收是不必要的。&lt;/p&gt;

&lt;p&gt;所以为了解决这个问题，结合&lt;code class=&quot;highlighter-rouge&quot;&gt;Mark-Compact&lt;/code&gt;，标记整理对象标记死亡后的碎片化空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/Mark-Compact%E6%95%B4%E7%90%86%E7%A2%8E%E7%89%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;Mark-Compact&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;三种垃圾回收算法简单对比&quot;&gt;三种垃圾回收算法简单对比&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回收算法&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Mark-Sweep&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Mark-Compact&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Scavenge&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;速度&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最慢&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最快&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;空间开销&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;少（有碎片）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;少（有碎片）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;双倍空间（无碎片）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是否移动对象&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;科目标签设置&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;查看垃圾回收日志&quot;&gt;查看垃圾回收日志&lt;/h3&gt;

&lt;p&gt;启动时添加trace_gc参数，在进行垃圾回收时，将会从标准输出中打印垃圾回收日志&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node &lt;span class=&quot;nt&quot;&gt;--trace_gc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;var a = []; for(var i = 0; i &amp;lt; 1000000; i++) a.push(new Array(100));&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gc.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;高效使用内存&quot;&gt;高效使用内存&lt;/h3&gt;

&lt;h4 id=&quot;作用域&quot;&gt;作用域&lt;/h4&gt;

&lt;h5 id=&quot;1标志符查找&quot;&gt;1.标志符查找&lt;/h5&gt;

&lt;p&gt;与作用域相关的即是标志符查找。所谓标志符，可以理解为变量名。&lt;/p&gt;

&lt;h5 id=&quot;2作用域链&quot;&gt;2.作用域链&lt;/h5&gt;

&lt;p&gt;一直沿着作用域链查找到全局作用域，最后抛出未定义错误。&lt;/p&gt;

&lt;h5 id=&quot;3变量的主动释放&quot;&gt;3.变量的主动释放&lt;/h5&gt;

&lt;p&gt;如果变量是全局变量（不通过&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;声明或定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;变量上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存对象，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。&lt;/p&gt;

&lt;p&gt;虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;操作和重新赋值具有相同的效果，但是在V8中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好。&lt;/p&gt;

&lt;h4 id=&quot;闭包&quot;&gt;闭包&lt;/h4&gt;

&lt;p&gt;实现外部作用域访问内部作用域中变量的方法叫做闭包。&lt;/p&gt;

&lt;p&gt;闭包是JavaScript的高级特性，在使用内存时，它的问题在于：一旦有变量引用了这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域产生的内存占用也不会得到释放。除非不再引用，才会逐步释放。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内存指标&quot;&gt;内存指标&lt;/h3&gt;

&lt;h4 id=&quot;内存使用情况&quot;&gt;内存使用情况&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;查看进程内存占用 &lt;code class=&quot;highlighter-rouge&quot;&gt;process.memoryUsage()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;os模块查看操作系统内存使用情况 &lt;code class=&quot;highlighter-rouge&quot;&gt;totalmem()&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;freemem()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;堆外内存&quot;&gt;堆外内存&lt;/h4&gt;

&lt;p&gt;不是通过V8分配的内存称为&lt;strong&gt;堆外内存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node的内存构成主要通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内存泄露&quot;&gt;内存泄露&lt;/h3&gt;

&lt;p&gt;通常造成内存泄露的原因：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;缓存&lt;/li&gt;
  &lt;li&gt;队列消费不及时&lt;/li&gt;
  &lt;li&gt;作用域未释放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript创建一个缓存对象&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// get from ohterwise&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;慎将内存做缓存&quot;&gt;慎将内存做缓存&lt;/h4&gt;

&lt;p&gt;缓存限制策略：限制键值数量，大小&lt;/p&gt;

&lt;p&gt;目前比较好的解决方案是采用进程外的缓存，进程本身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自身的内存管理，不影响Node进程的性能。&lt;/p&gt;

&lt;p&gt;在Node中主要可以解决一下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效&lt;/li&gt;
  &lt;li&gt;进程之间可以共享缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前推荐: &lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Memcached&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;关注队列状态&quot;&gt;关注队列状态&lt;/h4&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;消费速度 &amp;gt; 生产速度 = 正常&lt;/li&gt;
  &lt;li&gt;消费速度 &amp;lt; 生产速度 = 不正常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在队列实现时，优化代码的同时也要考虑到监控队列的长度，一旦消费速度小于生产速度，堆积对象过多时，应当通过系统产生报警并通知；或者任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个限定值。&lt;/p&gt;

&lt;h3 id=&quot;内存排查&quot;&gt;内存排查&lt;/h3&gt;

&lt;p&gt;常见工具&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;v8-profiler&lt;/li&gt;
  &lt;li&gt;node-heapdump&lt;/li&gt;
  &lt;li&gt;node-mtrace&lt;/li&gt;
  &lt;li&gt;dtrace&lt;/li&gt;
  &lt;li&gt;node-memwatch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般通过对堆内存进行分析而找到泄露原因。&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Jul 2017 21:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/25/learn-node-04-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/25/learn-node-04-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 03 day</title>
        <description>&lt;h2 id=&quot;函数式编程&quot;&gt;函数式编程&lt;/h2&gt;

&lt;h3 id=&quot;高阶函数&quot;&gt;高阶函数&lt;/h3&gt;

&lt;p&gt;高阶函数可以把函数作为参数，或是将函数作为返回值的函数，例如：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;偏函数&quot;&gt;偏函数&lt;/h3&gt;

&lt;p&gt;通过指定部分参数来产生一个新的定制函数的形式就是偏函数&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[object'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;']'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'String'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Function'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;异步编程解决方案&quot;&gt;异步编程解决方案&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型，这是它的灵魂所在。&lt;/strong&gt;
非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。对于网络应用而言，并行带来的想象空间更大，延展而开的是分布式和云。并行使得各个单点之间能够更有效地组织起来，这也是Node在云计算厂商中广受青睐的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E5%BC%82%E6%AD%A5I:O%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;异步I/O调用示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;难点1 异常处理&lt;/p&gt;

    &lt;p&gt;Node在处理一场上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常跑出。在我们自行编写的异步方法上，也需要去遵循这样一些原则：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;原则一：必须执行调用者传入的回调函数&lt;/li&gt;
      &lt;li&gt;原则二：正确传递回异常供调用者判断&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;难点2 函数嵌套过深&lt;/li&gt;
  &lt;li&gt;难点3 阻塞代码&lt;/li&gt;
  &lt;li&gt;难点4 多线程编程&lt;/li&gt;
  &lt;li&gt;难点5 异步转同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;主要解决方案如下3种&quot;&gt;主要解决方案如下3种&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;事件发布/订阅模式&lt;/li&gt;
  &lt;li&gt;Promise/Deferred模式&lt;/li&gt;
  &lt;li&gt;流程控制库&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;事件发布订阅模式&quot;&gt;事件发布/订阅模式&lt;/h4&gt;

&lt;p&gt;事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。通过&lt;code class=&quot;highlighter-rouge&quot;&gt;emit()&lt;/code&gt;发布事件后，消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活地添加和删除，使得事件和具体处理逻辑之间可以很轻松的关联和解耦。&lt;/p&gt;

&lt;p&gt;事件发布/订阅模式自身并无同步和异步调用的问题，但在Node中，&lt;code class=&quot;highlighter-rouge&quot;&gt;emit()&lt;/code&gt;调用多半是伴随事件循环而异步触发的，所以我们说事件发布/订阅广泛应用于异步编程。&lt;/p&gt;

&lt;p&gt;事件发布/订阅模式常常用来解耦业务逻辑，事件发布者无须关注订阅的侦听器如何实现业务逻辑，甚至不用关注有多少个侦听器存在，数据通过消息的方式可以很灵活地传递。在一些典型的场景中，可以通过事件发布/订阅模式进行组件封装，将不变的部分封装在组件内部，将容易变化，需自定义的部分通过事件暴露给外部处理，这是一种典型的逻辑分离方式。在这种事件发布/订阅式组件中，事件的设计非常重要，因为它关乎外部调用组件时是否优雅，从某种角度来说事件的设计就是组件的接口设计。&lt;/p&gt;

&lt;p&gt;从另一个角度来看，事件侦听器模式也是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt;，利用钩子导出内部数据或者状态给外部调用者。&lt;/p&gt;

&lt;h5 id=&quot;利用事件队列解决雪崩问题&quot;&gt;利用事件队列解决雪崩问题&lt;/h5&gt;

&lt;p&gt;在事件订阅/发布模式中，通常也有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;once()&lt;/code&gt;方法，通过它添加的侦听器只能执行一次，在执行之后就会将它与事件的关联移除。这个特性常常可以帮助我们过滤一些重复性的事件响应。&lt;/p&gt;

&lt;h5 id=&quot;多异步之间的协作方案&quot;&gt;多异步之间的协作方案&lt;/h5&gt;

&lt;p&gt;多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间相互没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量。&lt;/p&gt;

&lt;h4 id=&quot;promisedeferred模式&quot;&gt;Promise/Deferred模式&lt;/h4&gt;

&lt;h5 id=&quot;promise和deferred整体关系&quot;&gt;Promise和Deferred整体关系&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E6%B5%81%E7%A8%8B%E5%9B%BE/Promise%E5%92%8CDeferred%E6%95%B4%E4%BD%93%E5%85%B3%E7%B3%BB.png?raw=true&quot; alt=&quot;Promise和Deferred整体关系&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Promise是高级接口，事件是低级接口。低级接口可以构成更多更复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决典型问题非常有效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思考问题：Promise主要解决的是单个异步操作中存在的问题，当我们需要处理多个异步调用时又该如何处理呢?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'foo.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf-8'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'bar.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf-8'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//TODO&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//TODO&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;方法抽象多个异步操作，只有所有异步操作成功，这个异步操作才算成功，一旦其中一个异步操作失败，整个异步操作就失败。&lt;/p&gt;

&lt;h5 id=&quot;支持序列执行的promise&quot;&gt;支持序列执行的Promise&lt;/h5&gt;

&lt;p&gt;理想的编程体验应当是前一个的调用结果作为下一个调用的开始，是传说中的链式调用。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;api1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;api2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;api3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;api4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//TODO value4&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//TODO error from step1 through setp4&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要让promise支持链式执行，主要通过以下两个步骤&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将所有回调都存在队列中&lt;/li&gt;
  &lt;li&gt;promise完成时，逐个执行回调，一旦检测到返回了新的promise对象，停止执行，然后将当前的Deferred对象的promise引用改为新的promise对象，并将队列中余下的回调转交给它。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;流程控制库&quot;&gt;流程控制库&lt;/h4&gt;

&lt;h5 id=&quot;尾触发与next&quot;&gt;尾触发与next&lt;/h5&gt;

&lt;p&gt;有一类需要手工调用才能持续执行后续调用，我们将此类方法叫做尾触发。常见关键词是next()。应用最多的地方是Connect的中间件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/流程图/中间件通过队列形成一个处理流.png?raw=true&quot; alt=&quot;中间件通过队列形成一个处理流&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;async&quot;&gt;async&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;series 实现一组任务的串行执行，适合无依赖的异步&lt;/li&gt;
  &lt;li&gt;parallel 并行执行异步操作&lt;/li&gt;
  &lt;li&gt;waterfall 执行存在依赖的异步操作&lt;/li&gt;
  &lt;li&gt;auto 自动分析依赖执行异步操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;step&quot;&gt;step&lt;/h5&gt;

&lt;p&gt;接收任意数量的任务，所有的任务都将会串行一次执行。&lt;/p&gt;

&lt;h5 id=&quot;wind&quot;&gt;wind&lt;/h5&gt;

&lt;h4 id=&quot;流程控制小结&quot;&gt;流程控制小结&lt;/h4&gt;

&lt;p&gt;事件发布/订阅模式相对算是一种较为原始的方式，&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise/Deferred&lt;/code&gt;模式贡献了一个非常不错的异步任务模型的抽象。上面几种异步流程控制方案与&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise/Deferred&lt;/code&gt;模式的思路不同，Promise/Deferred的重点在于封装异步的调用部分，流程控制库则显得没有模式，将处理重点放在回调函数的注入上。从自由度上来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;setp&lt;/code&gt;这类的流程控制库相对灵活得多。&lt;code class=&quot;highlighter-rouge&quot;&gt;EventProxy&lt;/code&gt;库则主要借鉴事件发布/订阅模式和流程控制库通过高阶函数生成回调函数的方式实现。&lt;/p&gt;

&lt;h3 id=&quot;异步并发控制&quot;&gt;异步并发控制&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 并发量过大时，下层服务器会吃不消，如果是对文件系统进行大量的并发调用，操作系统的文件描述符数量会被瞬间用光，抛出如下错误&lt;code class=&quot;highlighter-rouge&quot;&gt;Error: EMFLIE, too many open files&lt;/code&gt;。可以看出，异步I/O与同步I/O的明显差距：同步I/O因为每个I/O都彼此阻塞，在循环体中，总有一个接着一个调用，不会出现耗用文件描述符太多的情况，同时性能也是低下的；对于异步I/O，虽然并发容易实现，但是由于太容易实现依然需要控制。换言之，尽管要压榨底层系统的性能，但还是要给予一定的过载保护。&lt;/p&gt;

&lt;h3 id=&quot;bagpipe&quot;&gt;bagpipe&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过一个队列控制并发量&lt;/li&gt;
  &lt;li&gt;如果当前活跃（调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行&lt;/li&gt;
  &lt;li&gt;如果活跃调用达到限定值，调用暂时存放在队列中&lt;/li&gt;
  &lt;li&gt;每个异步调用结束时，从队列中取出新的异步调用执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;async-1&quot;&gt;async&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;parallelLimit 异步调用限制&lt;/li&gt;
  &lt;li&gt;queue 动态增加并行任务&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 07:21:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/18/learn-node-03-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/18/learn-node-03-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 02 day</title>
        <description>&lt;h2 id=&quot;为什么要异步io&quot;&gt;为什么要异步IO&lt;/h2&gt;

&lt;h3 id=&quot;用户体验&quot;&gt;用户体验&lt;/h3&gt;
&lt;p&gt;如果脚本执行的时间超过100毫秒，用户就会感到页面的卡顿，以为网址停止响应。通过同步的方式获取资源，那么javascript则需要等待资源完全从服务器端获取后才能继续执行，这期间UI将停顿，不响应用户的交互行为；而采用异步请求，在下载资源期间，javascript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O是昂贵的，分布式I/O是更昂贵的&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;资源分配&quot;&gt;资源分配&lt;/h3&gt;

&lt;p&gt;问题：在计算机资源中，通常I/O与CPU计算之间是可以并行进行的，但是同步的编程模型导致的问题是，I/O的进行会让后续任务等待，这会造成资源不能被更好的利用。&lt;/p&gt;

&lt;p&gt;Node给出了好的解决方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好的利用CPU。&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Windows&lt;/code&gt;平台和&lt;code class=&quot;highlighter-rouge&quot;&gt;*nix&lt;/code&gt;平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的自定义线程池及IOCP之间各自独立。Node在编译期间会判断平台条件，选择性的编译&lt;code class=&quot;highlighter-rouge&quot;&gt;unix&lt;/code&gt;目录或者&lt;code class=&quot;highlighter-rouge&quot;&gt;win&lt;/code&gt;目录下的源文件到目标程序中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们时常提到的Node是单线程的，这里的单线程仅仅只是JavaScript执行在单线程中而已。在Node中，无论是&lt;code class=&quot;highlighter-rouge&quot;&gt;*nix&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;windows&lt;/code&gt;平台，内部完成I/O任务的另有线程池。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;node的异步io&quot;&gt;Node的异步I/O&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;事件循环&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;观察者&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;请求对象&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O线程池&lt;/code&gt;这四者共同构成Node模型的基本要素&lt;/p&gt;

&lt;h3 id=&quot;事件循环&quot;&gt;事件循环&lt;/h3&gt;

&lt;p&gt;在进程启动时，node会创建一个类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;while(true)&lt;/code&gt;的循环，每执行一次循环体的过程称为&lt;code class=&quot;highlighter-rouge&quot;&gt;Tick&lt;/code&gt;。每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Tick&lt;/code&gt;的过程就是查看是否有事件待处理，如果有就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理就退出进程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件循环是一个典型的生产者／消费者模型&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;观察者&quot;&gt;观察者&lt;/h3&gt;

&lt;p&gt;每一个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。&lt;/p&gt;

&lt;h3 id=&quot;请求对象&quot;&gt;请求对象&lt;/h3&gt;

&lt;p&gt;请求对象是异步I/O过程中重要的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。&lt;/p&gt;

&lt;h3 id=&quot;执行回调io线程池&quot;&gt;执行回调（I/O线程池）&lt;/h3&gt;

&lt;p&gt;每次Tick执行，检查线程池中是否有执行完的请求，如果存在，将请求对象加入到I/O观察者的队列中，然后将其当作事件处理。&lt;/p&gt;

&lt;p&gt;I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，这样就能达到调用javascript中传入的回调函数的目的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O）都是可以并行执行的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。使得服务器能够有条不紊地处理请求，即使在大量链接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;流程图&quot;&gt;流程图&lt;/h2&gt;

&lt;h2&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E6%B5%81%E7%A8%8B%E5%9B%BE/Tick%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true&quot; alt=&quot;Tick流程图&quot; /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;-1&quot;&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E5%9F%BA%E4%BA%8Elibuv%E7%9A%84%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;基于libuv的架构示意图&quot; /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;-2&quot;&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E6%95%B4%E4%B8%AA%E5%BC%82%E6%AD%A5I:O%E6%B5%81%E7%A8%8B.png?raw=true&quot; alt=&quot;整个异步I/O流程&quot; /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;-3&quot;&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E6%B5%81%E7%A8%8B%E5%9B%BE/%E5%9F%BA%E4%BA%8ENode%E6%9E%84%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true&quot; alt=&quot;基于Node构建Web服务器流程图&quot; /&gt;&lt;/h2&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 07:00:34 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/18/learn-node-02-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/18/learn-node-02-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 01 day</title>
        <description>&lt;h2 id=&quot;包与npm&quot;&gt;包与NPM&lt;/h2&gt;

&lt;h3 id=&quot;包结构&quot;&gt;包结构&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;完全符合CommonJs规范的包目录应该包含如下文件：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;package.json: 包描述文件&lt;/li&gt;
  &lt;li&gt;bin: 用于存放可执行二进制文件的目录&lt;/li&gt;
  &lt;li&gt;lib: 用于存放JavaScript代码的目录&lt;/li&gt;
  &lt;li&gt;doc: 用于存放文档的目录&lt;/li&gt;
  &lt;li&gt;test: 用于存放单元测试用例的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CommonJs package.json必须字段：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;name: 包名&lt;/li&gt;
  &lt;li&gt;description: 包简介&lt;/li&gt;
  &lt;li&gt;vsersion: 版本号，一般为&lt;code class=&quot;highlighter-rouge&quot;&gt;major.minor.revision&lt;/code&gt;格式&lt;/li&gt;
  &lt;li&gt;keywords: 关键词数组&lt;/li&gt;
  &lt;li&gt;maintainers: 包维护者列表&lt;/li&gt;
  &lt;li&gt;contributors: 贡献者列表&lt;/li&gt;
  &lt;li&gt;bugs: 一个可以反馈bug的地址&lt;/li&gt;
  &lt;li&gt;licenses: 许可证列表&lt;/li&gt;
  &lt;li&gt;repositories: 托管源代码的位置列表&lt;/li&gt;
  &lt;li&gt;dependencied: 当前包所需依赖的列表&lt;/li&gt;
  &lt;li&gt;homepage: 当前包的网站地址&lt;/li&gt;
  &lt;li&gt;os: 操作系统支持列表&lt;/li&gt;
  &lt;li&gt;cpu: cpu架构支持列表&lt;/li&gt;
  &lt;li&gt;engine: 支持的javascript引擎列表&lt;/li&gt;
  &lt;li&gt;builtin: 标志当前包是否是内建在底层系统的标准组件&lt;/li&gt;
  &lt;li&gt;directores: 包目录说明&lt;/li&gt;
  &lt;li&gt;implements: 实现规范的列表&lt;/li&gt;
  &lt;li&gt;scripts: 让包安装或者卸载等过程中提供钩子机制
&lt;strong&gt;&lt;em&gt;npm 补充：&lt;/em&gt;&lt;/strong&gt; author, bin, main, devDependencies&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;发布包&quot;&gt;发布包&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.创建文件夹 npm-package-dev
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;npm-package-dev

2.进入文件夹
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;npm-package-dev

3.初始化npm包
npm init

4.注册仓库账号
npm adduser

5.上传包
npm publish

6.执行 npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &amp;lt;name&amp;gt; 安装包，其中name为npm init时填写的name字段
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如何选择好的包&quot;&gt;如何选择好的包&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;具备良好的测试&lt;/li&gt;
  &lt;li&gt;具备良好的文档&lt;/li&gt;
  &lt;li&gt;具备良好的测试覆盖率&lt;/li&gt;
  &lt;li&gt;具备良好的编码规范&lt;/li&gt;
  &lt;li&gt;更多条件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;前后端公用模块&quot;&gt;前后端公用模块&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;AMD规范&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;定义： define(id?, dependencies?, factory)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;id 和 dependencies可选，factory为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayHello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Hello, World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CMD规范&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;定义： define(factory)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与AMD相比，AMD需要在声明时指定所有依赖，CMD支持动态引入&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;modules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// The module code goes here&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 07:00:34 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/17/learn-node-01-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/17/learn-node-01-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
  </channel>
</rss>
