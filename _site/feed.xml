<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>peakcool | 个人博客</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://peakcool.cn/</link>
    <atom:link href="http://peakcool.cn/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 28 Dec 2018 11:55:23 +0800</pubDate>
    <lastBuildDate>Fri, 28 Dec 2018 11:55:23 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Mac解压rar文件</title>
        <description>&lt;h2 id=&quot;mac解压tar文件&quot;&gt;Mac解压tar文件&lt;/h2&gt;

&lt;p&gt;客户呼啦一下，一言不合扔过来一堆rar压缩文件，自己现MAC上没有对应的解压软件&lt;/p&gt;

&lt;p&gt;google一番，发现homebrew可以安装对应的工具命令行解压&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;unrar
Updating Homebrew...
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Auto-updated Homebrew!
Updated 2 taps &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;homebrew/core and homebrew/cask&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Updated Formulae
babel                             jenkins                           jenkins-lts                       macvim                            taskell                           webpack

&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Downloading https://homebrew.bintray.com/bottles/unrar-5.6.8.mojave.bottle.tar.gz
&lt;span class=&quot;c&quot;&gt;######################################################################## 100.0%&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装成功后，执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd rarFileParentPath

unrar x rarFileName
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 06 Dec 2018 19:15:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/12/06/Mac%E8%A7%A3%E5%8E%8Brar%E6%96%87%E4%BB%B6.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/12/06/Mac%E8%A7%A3%E5%8E%8Brar%E6%96%87%E4%BB%B6.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>Cordova iOS 多媒体播放器允许行内播放</title>
        <description>&lt;h2 id=&quot;cordova-ios-多媒体播放器允许行内播放&quot;&gt;Cordova iOS 多媒体播放器允许行内播放&lt;/h2&gt;

&lt;p&gt;最近在cordova app上实现多媒体播放的功能时，遇到一个问题&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ios 默认不支持video行内播放&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;google一番，搜集了关于这个问题的信息&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;h5 video标签禁止全屏播放
 &lt;code class=&quot;highlighter-rouge&quot;&gt;在video标签中设置webkit-playsinline=&quot;true&quot; playsinline=&quot;true&quot;等值&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cordova-plugin-wkwebview-engine 上README提到&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;The AllowInlineMediaPlayback preference will not work because of this Apple bug. This bug has been fixed in iOS 10.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Apple 为了多媒体播放更好的用户体验，默认不允许行内播放，所以需要手动自己开启&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 在cordova/config.xml中，新增
 &amp;lt;preference name=&quot;AllowInlineMediaPlayback&quot; value=&quot;true&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 29 Oct 2018 06:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/29/cordova-ios-video-player.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/29/cordova-ios-video-player.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>gem安装依赖失败</title>
        <description>&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#gem安装依赖失败&quot;&gt;gem安装依赖失败&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;gem安装依赖失败&quot;&gt;gem安装依赖失败&lt;/h2&gt;

&lt;p&gt;很久没有写博客了，最近也新换了电脑，重新把博客从github上拉下来。&lt;/p&gt;

&lt;p&gt;安装了&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll&lt;/code&gt;后，满心欢喜的执行&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt; 终端里得来的却是无情的红色报错，心里顿时一凉，好不容易想写文章的热情也被浇灭。&lt;/p&gt;

&lt;p&gt;终于2天后，还是静下心来把这些问题解决。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;run &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install bundle&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;remove &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile.lock&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;run &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo bundle install&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这时再启动，发现报错&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Library/Ruby/Gems/2.3.0/gems/bundler-1.17.1/lib/bundler/runtime.rb:319:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;check_for_activated_spec!&lt;span class=&quot;s1&quot;&gt;': You have already activated i18n 1.1.1, but your Gemfile requires i18n 0.9.5. Prepending `bundle exec` to your command may solve this. (Gem::LoadError)
	from /Library/Ruby/Gems/2.3.0/gems/bundler-1.17.1/lib/bundler/runtime.rb:31:in `block in setup'&lt;/span&gt;
	from /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/2.3.0/forwardable.rb:202:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;each&lt;span class=&quot;s1&quot;&gt;'
	from /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/2.3.0/forwardable.rb:202:in `each'&lt;/span&gt;
	from /Library/Ruby/Gems/2.3.0/gems/bundler-1.17.1/lib/bundler/runtime.rb:26:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;map&lt;span class=&quot;s1&quot;&gt;'
	from /Library/Ruby/Gems/2.3.0/gems/bundler-1.17.1/lib/bundler/runtime.rb:26:in `setup'&lt;/span&gt;
	from /Library/Ruby/Gems/2.3.0/gems/bundler-1.17.1/lib/bundler.rb:107:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;setup&lt;span class=&quot;s1&quot;&gt;'
	from /Library/Ruby/Gems/2.3.0/gems/jekyll-3.8.4/lib/jekyll/plugin_manager.rb:50:in `require_from_bundler'&lt;/span&gt;
	from /Library/Ruby/Gems/2.3.0/gems/jekyll-3.8.4/exe/jekyll:11:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&amp;lt;top &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;required&lt;span class=&quot;o&quot;&gt;)&amp;gt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
	from /usr/local/bin/jekyll:22:in `load'&lt;/span&gt;
	from /usr/local/bin/jekyll:22:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&amp;lt;main&amp;gt;&lt;span class=&quot;s1&quot;&gt;'
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时再执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem unintall i18n&lt;/code&gt;，选择移除&lt;code class=&quot;highlighter-rouge&quot;&gt;1.1.1&lt;/code&gt;版本&lt;/p&gt;

&lt;p&gt;大功告成！&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Oct 2018 05:40:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/29/gem-install-bundle-faile.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/29/gem-install-bundle-faile.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>Flutter Gradle Run Build Failed</title>
        <description>&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#flutter-gradle编译失败&quot;&gt;Flutter Gradle编译失败&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#错误日志&quot;&gt;错误日志&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#解决办法&quot;&gt;解决办法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;flutter-gradle编译失败&quot;&gt;Flutter Gradle编译失败&lt;/h2&gt;

&lt;h3 id=&quot;错误日志&quot;&gt;错误日志&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Launching lib/main.dart on Android SDK built for x86 in debug mode...
Initializing gradle...
Resolving dependencies...
* Error running Gradle:
Exit code 1 from: /Users/tangliangcheng/AndroidStudioProjects/flutter_app_demo01/android/gradlew app:properties:
Starting a Gradle Daemon (subsequent builds will be faster)

Project evaluation failed including an error in afterEvaluate {}. Run with --stacktrace for details of the afterEvaluate {} error.

FAILURE: Build failed with an exception.

* Where:
Build file '/Users/tangliangcheng/AndroidStudioProjects/flutter_app_demo01/android/app/build.gradle' line: 25

* What went wrong:
A problem occurred evaluating project ':app'.
&amp;gt; Could not resolve all files for configuration 'classpath'.
   &amp;gt; Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2).
     Searched in the following locations:
         https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 10s

Finished with error: Please review your Gradle project setup in the android/ folder.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;flutter⁩ ▸ ⁨packages⁩ ▸ ⁨flutter_tools⁩ ▸ ⁨gradle⁩&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;buildscript {
    repositories {
	google() //添加
        jcenter()
        maven {
            url 'https://dl.google.com/dl/android/maven2'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 28 Oct 2018 00:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/28/flutter-gradle-build.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/28/flutter-gradle-build.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>Cordova Android 扫码返回按钮路由返回上一级</title>
        <description>&lt;h2 id=&quot;cordova-android-扫码返回按钮路由回退&quot;&gt;Cordova Android 扫码返回按钮路由回退&lt;/h2&gt;

&lt;p&gt;最近在实现cordova 扫码需求时，用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;phonegap-plugin-barcodescanner&lt;/code&gt;库&lt;/p&gt;

&lt;p&gt;开启相机后，在android上，没有&lt;code class=&quot;highlighter-rouge&quot;&gt;取消扫码&lt;/code&gt;按钮，只能点击&lt;code class=&quot;highlighter-rouge&quot;&gt;返回&lt;/code&gt;按钮才能取消扫码&lt;/p&gt;

&lt;p&gt;这时会有一个问题，点击返回按钮时，webview路由会&lt;code class=&quot;highlighter-rouge&quot;&gt;go(-1)&lt;/code&gt;并且取消扫码关闭相机&lt;/p&gt;

&lt;p&gt;而实际期望的是关闭相机，路由不返回上一级&lt;/p&gt;

&lt;p&gt;在vue项目中解决思路是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. vuex中创建一个值 state.unBack = false作为临时保存扫码开启状态
2. 开启扫码时，设置 state.unBack = true
3. 在当前页路由勾子 beforeRouteLeave 中，判断unBack是否会false, false时正常路由行为， true时next(false)阻止路由跳转
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 17 Oct 2018 06:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/17/cordova-android-scanner.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2018/10/17/cordova-android-scanner.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 08 day</title>
        <description>&lt;h2 id=&quot;玩转进程&quot;&gt;玩转进程&lt;/h2&gt;

&lt;h3 id=&quot;多进程架构&quot;&gt;多进程架构&lt;/h3&gt;

&lt;h4 id=&quot;master-worker模式主从模式&quot;&gt;Master-Worker模式（主从模式）&lt;/h4&gt;

&lt;p&gt;图中进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或者管理工作进程，它是趋向稳定的。工作进程负责具体的业务处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/Master-Worder%E6%A8%A1%E5%BC%8F.png?raw=true&quot; alt=&quot;Master-Worker&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建子进程&quot;&gt;创建子进程&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;child_process&lt;/code&gt;模块提供了4个方法用于创建子进程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;spawn(): 启动一个子进程来执行命令&lt;/li&gt;
  &lt;li&gt;exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况&lt;/li&gt;
  &lt;li&gt;execFile(): 启动该一个子进程来执行可执行文件&lt;/li&gt;
  &lt;li&gt;fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的javascript文件模块即可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;spawn()与exec()、execFile()不同的是，后两者创建的时间可以指定&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4种方法的差别&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;回调/异常&lt;/th&gt;
      &lt;th&gt;进程类型&lt;/th&gt;
      &lt;th&gt;执行类型&lt;/th&gt;
      &lt;th&gt;可设置超时&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;spawn()&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
      &lt;td&gt;任意&lt;/td&gt;
      &lt;td&gt;命令&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;exec()&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
      &lt;td&gt;任意&lt;/td&gt;
      &lt;td&gt;命令&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;execFile()&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
      &lt;td&gt;任意&lt;/td&gt;
      &lt;td&gt;可执行文件&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fork()&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
      &lt;td&gt;Node&lt;/td&gt;
      &lt;td&gt;JavaScript文件&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;进程间通信&quot;&gt;进程间通信&lt;/h4&gt;

&lt;p&gt;主进程与工作线程之间通过&lt;code class=&quot;highlighter-rouge&quot;&gt;onmessage()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage()&lt;/code&gt;进行通信，子进程对象则由&lt;code class=&quot;highlighter-rouge&quot;&gt;send()&lt;/code&gt;方法实现主进程向子进程发送数据,&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件实现收听子进程发来的数据。&lt;/p&gt;

&lt;h4 id=&quot;进程间通信原理&quot;&gt;进程间通信原理&lt;/h4&gt;

&lt;p&gt;IPC的全称是Inter-Process Communication,即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并协调工作。实现进程间通信的结束有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道(pipe)技术。但是此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道( named pipe ) 实现， *nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法。&lt;/p&gt;

&lt;p&gt;父进程在实际创建子进程之前，会创建IPC通道去监听它，然后才真正创建出子进程，并通过环境变量(NODE_CHANNEL_FD)告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已经存在的IPC通道，从而完成父子进程之间的连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IPC创建和实现示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/IPC%E5%88%9B%E5%BB%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;IPC创建和实现示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建IPC管道的步骤示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E5%88%9B%E5%BB%BAIPC%E7%AE%A1%E9%81%93%E7%9A%84%E6%AD%A5%E9%AA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：只有启动的子进程是Node进程时&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;句柄传递&quot;&gt;句柄传递&lt;/h4&gt;

&lt;p&gt;只有一个进程可以监听到一个端口上，其余的进程在监听的过程中都会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;EADDRINUSE&lt;/code&gt;异常，这是端口被占用的情况，新的进程不能继续监听该端口。这个问题破坏我们将多个进程监听同一个端口的想法。要解决这个问题，通常的做法是让每个进程监听不同的端口，其中主进程监听主端口（如80），主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口进程上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E4%B8%BB%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6%E3%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;主进程接收、分配网络请求示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上适当的负载均衡，使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程中需要用掉2个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了系统的扩展能力。&lt;/p&gt;

&lt;p&gt;为了解决上述这样的问题，Node在版本v0.5.9引入了进程间发送句柄的功能。send()方法除了能通过IPC发送数据外，还能发送句柄，第二个可选参数就是句柄，如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sendHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;什么是句柄呢？&lt;strong&gt;句柄是一种可以用来标识资源的引用&lt;/strong&gt;，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象，一个客户端socket对象、一个UDP套接字、一个管道等。&lt;/p&gt;

&lt;p&gt;发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程间建立新的socket连接来转发数据。文件描述符浪费的问题可以通过这种方式轻松解决。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%B0%86%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E7%BB%99%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%202.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主进程代码:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'child_process'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'child.js'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'net'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'handle by parent'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1337&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'server'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子进程代码:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'message'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'server'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'handle by child'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再优化，将服务器句柄发送给子进程之后，关闭服务器监听，让子进程处理请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E7%8E%A9%E8%BD%AC%E8%BF%9B%E7%A8%8B/%E5%8F%A5%E6%9F%84%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E8%BF%98%E5%8E%9F%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;句柄的发送与还原示意图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;句柄发送与还原&quot;&gt;句柄发送与还原&lt;/h4&gt;

&lt;p&gt;目前子进程对象send()方法可以发送的句柄类型包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;net.Socket TCP套接字&lt;/li&gt;
  &lt;li&gt;net.Server TCP服务器&lt;/li&gt;
  &lt;li&gt;net.Navtive C++层面的TCP套接字或者IPC管道&lt;/li&gt;
  &lt;li&gt;dgram.Socket UDP套接字&lt;/li&gt;
  &lt;li&gt;dgram.Native C++层面的UDP套接字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;，另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;参数如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'NODE_HANDLE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'net.Server'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;发送到IPC管道中的实际是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。&lt;/p&gt;

&lt;p&gt;多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用，换言之就是网络请求向服务器端发送请求时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是&lt;strong&gt;抢占式&lt;/strong&gt;的。&lt;/p&gt;

&lt;h3 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h3&gt;

&lt;p&gt;在进程间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来。&lt;/p&gt;

&lt;p&gt;比如：饭店将客人的点单分发给多个厨师进行点餐点制作。既然涉及多个厨师共同处理所有菜单，那么保证每个厨师的工作量是一门学问，既不能让一些厨师忙不过来，也不能让一些厨师闲着，这个保证多个处理单元工作量公平的策略叫做&lt;strong&gt;负载均衡&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Node默认提供的机制是&lt;strong&gt;抢占式&lt;/strong&gt;策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。&lt;/p&gt;

&lt;p&gt;为此Node在v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫做&lt;strong&gt;Round-Robin 伦叫调度&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 06:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/11/learn-node-08-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/11/learn-node-08-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 07 day</title>
        <description>&lt;h2 id=&quot;构建web应用&quot;&gt;构建Web应用&lt;/h2&gt;

&lt;p&gt;从http模块中服务器端的&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;事件开始分析。&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;事件发生于网络连接的建立，客户端向服务器端发送报文，服务器端解析报文，发送HTTP请求的报头时.&lt;/p&gt;

&lt;p&gt;在具体的业务中，一般会有如下需求:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求方法的判断&lt;/li&gt;
  &lt;li&gt;URL的路径解析&lt;/li&gt;
  &lt;li&gt;URL中查询字符串解析&lt;/li&gt;
  &lt;li&gt;Cookie的解析&lt;/li&gt;
  &lt;li&gt;Basic认证&lt;/li&gt;
  &lt;li&gt;表单数据的解析&lt;/li&gt;
  &lt;li&gt;任意格式文件的上传处理&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cookie&quot;&gt;Cookie&lt;/h3&gt;

&lt;p&gt;Cookie的处理分为如下几步:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器向客户端发送Cookie&lt;/li&gt;
  &lt;li&gt;浏览器将Cookie保存&lt;/li&gt;
  &lt;li&gt;之后每次刷新浏览器都会将Cookie发向服务器端&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cookie参数&quot;&gt;Cookie参数&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器不发送这个Cookie&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Max-Age&lt;/code&gt;是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中保存，下次打开浏览器依然有效。&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时过期。&lt;code class=&quot;highlighter-rouge&quot;&gt;Max-Age&lt;/code&gt;则告知浏览器多久后过期，当两个值同时存在时，且同时被支持时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Max-Age&lt;/code&gt;会覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HttpOnly&lt;/code&gt;告知浏览器不允许通过脚本&lt;code class=&quot;highlighter-rouge&quot;&gt;document.cookie&lt;/code&gt;去更改这个Cookie值，事实上，设置&lt;code class=&quot;highlighter-rouge&quot;&gt;HttpOnly&lt;/code&gt;之后，这个值在&lt;code class=&quot;highlighter-rouge&quot;&gt;document.cookie&lt;/code&gt;中不可见，但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Secure&lt;/code&gt; 当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，很难被窃听到&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cookie的性能影响&quot;&gt;Cookie的性能影响&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;减少Cookie的大小&lt;/li&gt;
  &lt;li&gt;为静态组件使用不同的域名&lt;/li&gt;
  &lt;li&gt;减少DNS查询&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;session&quot;&gt;Session&lt;/h3&gt;

&lt;h4 id=&quot;session与内存&quot;&gt;Session与内存&lt;/h4&gt;

&lt;p&gt;为了解决性能问题和&lt;code class=&quot;highlighter-rouge&quot;&gt;Session&lt;/code&gt;数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是&lt;code class=&quot;highlighter-rouge&quot;&gt;redies&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;memcached&lt;/code&gt;等。通过这些高效的缓存，node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都迎刃而解&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;session与安全&quot;&gt;Session与安全&lt;/h4&gt;

&lt;p&gt;典型的&lt;code class=&quot;highlighter-rouge&quot;&gt;XXS&lt;/code&gt;(跨站脚本攻击 Cross Site Scripting)拿到用户口令，实现伪造，通常都是由网站开发者决定哪些脚本可以执行在浏览器端，不过&lt;code class=&quot;highlighter-rouge&quot;&gt;XXS&lt;/code&gt;漏洞会让别的脚本执行。它的主要形成原因多数是用户的输入没有被转义，而被直接执行。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;缓存&quot;&gt;缓存&lt;/h3&gt;

&lt;h4 id=&quot;使用缓存流程图&quot;&gt;使用缓存流程图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80web%E5%BA%94%E7%94%A8/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;使用缓存流程图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;缓存设置&quot;&gt;缓存设置&lt;/h4&gt;

&lt;h4 id=&quot;清除缓存&quot;&gt;清除缓存&lt;/h4&gt;

&lt;p&gt;知晓了如何设置缓存，以达到节省网络带宽的目的，但是缓存一旦设定，当服务器端意外更新内容时，却无法通知客户端更新。这使得我们在使用缓存时也要为其设定版本号，所幸浏览器根据URL进行缓存，那么一旦内容更新时，我们就让浏览器发起新的url请求，使新内容能够被客户端更新。一般的更新机制有如下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次发布，路径中跟随web应用的版本号： http://url.com/?v=20170801&lt;/li&gt;
  &lt;li&gt;每次发布，路径中跟随该文件内容的hash值： http://url.com/?hash=afadsad11sad&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说根据文件内容的hash值进行缓存淘汰更加高效，因为文件内容不一定跟随web应用的版本而更新，而内容没有更新时，版本号的改动导致更新毫无意义，因此以文件内容形成的hash值更精确&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;数据上传&quot;&gt;数据上传&lt;/h3&gt;

&lt;p&gt;Node的http模块只对HTTP报文的头部进行了解析，然后触发request事件。如果请求中还带有内部部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。通过设置报头的&lt;code class=&quot;highlighter-rouge&quot;&gt;Transfer-Encoding&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;即可判断请求中是否带有内容。&lt;/p&gt;

&lt;h4 id=&quot;表单数据&quot;&gt;表单数据&lt;/h4&gt;

&lt;p&gt;默认的表单提交，请求头中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;字段值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;其他格式&quot;&gt;其他格式&lt;/h4&gt;

&lt;p&gt;常见的提交还有JSON和XML文件等，判断和解析他们的原理都比较相似，都是依据&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;的值决定，其中JSON类型的值为application/json,XML的值为application/xml&lt;/p&gt;

&lt;p&gt;需要注意的是，在Content-Type中可能还会附带&lt;code class=&quot;highlighter-rouge&quot;&gt;charset=utf-8&lt;/code&gt;的编码信息。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;中间件与性能&quot;&gt;中间件与性能&lt;/h3&gt;

&lt;h4 id=&quot;中间件的工作模型&quot;&gt;中间件的工作模型&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80web%E5%BA%94%E7%94%A8/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.png?raw=true&quot; alt=&quot;中间件的工作模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要能提升性能的点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编写高效的中间件
  提升单个中间件的处理速度，以尽早调用next()执行后续逻辑。需要知道的是，一旦中间件被匹配，那么每个请求都会使该中间件执行一次，哪怕它只浪费了1毫秒的执行时间都会让我们QPS显著下降，常见的优化方法有几种。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;使用高效的方法，必要时通过jsperf.com测试基准性能&lt;/li&gt;
      &lt;li&gt;缓存需要重复计算的接口&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理利用路由，避免不必要的中间件执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;页面渲染&quot;&gt;页面渲染&lt;/h2&gt;

&lt;h3 id=&quot;mime&quot;&gt;MIME&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MIME&lt;/code&gt;的全称是&lt;code class=&quot;highlighter-rouge&quot;&gt;Multipurpose Internet Mail Extensions&lt;/code&gt;,从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;MIME&lt;/code&gt;值，如JSON文件的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/json&lt;/code&gt;，XML文件的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/xml&lt;/code&gt;，PDF文件的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;application/pdf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Node社区中&lt;code class=&quot;highlighter-rouge&quot;&gt;mime&lt;/code&gt;模块可以判断文件类型。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mime'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/path/to/file.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/plain'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'file.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/plain'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.TXT'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/plain'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'htm'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=&amp;gt; 'text/html'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Disposition&lt;/code&gt;: 无论响应的内容是什么样的&lt;code class=&quot;highlighter-rouge&quot;&gt;MIME&lt;/code&gt;值，不要求客户端去打开它，只需弹出并下载它。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Aug 2017 05:03:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/06/learn-node-07-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/06/learn-node-07-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 06 day</title>
        <description>&lt;h3 id=&quot;构建tcp服务&quot;&gt;构建TCP服务&lt;/h3&gt;

&lt;h4 id=&quot;tcp&quot;&gt;TCP&lt;/h4&gt;

&lt;p&gt;全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链路层、网络传输层、会话层、表示层、应用层）中属于传输层协议。&lt;/p&gt;

&lt;p&gt;其最显著的特征是在传输之间需要3次握手形成会话，只有会话形成之后，服务器端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个&lt;code class=&quot;highlighter-rouge&quot;&gt;套接字&lt;/code&gt;，这两个套接字共同形成一个链接。服务器端与客户端则通过套接字实现两者之间链接的操作。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;net&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'net'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Hello'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'end'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'连接断开'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8124&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'server bound'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//成功&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;tcp服务的事件&quot;&gt;TCP服务的事件&lt;/h4&gt;

&lt;p&gt;在上述示例中，代码分为服务器事件和连接事件。&lt;/p&gt;

&lt;h5 id=&quot;服务器事件&quot;&gt;服务器事件&lt;/h5&gt;
&lt;p&gt;对于通过&lt;code class=&quot;highlighter-rouge&quot;&gt;net.createServer()&lt;/code&gt;创建的服务器，它是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EventEmitter&lt;/code&gt;实例，它自定义事件有如下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;listening: 在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;server.listen()&lt;/code&gt;绑定端口或者Domain Socket后触发，简洁写法为&lt;code class=&quot;highlighter-rouge&quot;&gt;server.list(port, listeningListener)&lt;/code&gt;，通过第二个参数传入。&lt;/li&gt;
  &lt;li&gt;connection: 每个客户端套接字连接到服务器端时触发，简洁写法为&lt;code class=&quot;highlighter-rouge&quot;&gt;net.createServer()&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;close: 当服务器关闭时触发，在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;server.close()&lt;/code&gt;后，服务器将停止接受新的套接字连接，但保持当前连接，等所有连接断开后会触发该事件。&lt;/li&gt;
  &lt;li&gt;error: 当服务器发生异常时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;连接事件&quot;&gt;连接事件&lt;/h5&gt;

&lt;p&gt;服务器可以同时与多个客户端保持连接，对于每个连接而言就是典型的可写可读&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;对象可以用于服务器端和客户端之间的通信，既可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;事件从一端读取另一端发来的数据，也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;方法从一端向另外一端发送数据。具有如下自定义事件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data: 当一端调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;发送数据时，另一端会触发&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;事件，事件传递的数据即是&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;发送的数据。(&lt;strong&gt;注意:&lt;/strong&gt;并不是每次write都会触发一次data事件,当关闭&lt;code class=&quot;highlighter-rouge&quot;&gt;Nagle&lt;/code&gt;算法后，另一端可能收到多个小数据包合并，只触发一次data事件)&lt;/li&gt;
  &lt;li&gt;end: 当连接中的任意一端发送了FIN数据时，将会触发该事件。&lt;/li&gt;
  &lt;li&gt;connect: 该事件用于客户端，当套接字与服务器端连接成功时会被触发。&lt;/li&gt;
  &lt;li&gt;drain: 当任意一端调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;发送数据时，当前这端会触发该事件。&lt;/li&gt;
  &lt;li&gt;error: 当异常发生时，触发该事件。&lt;/li&gt;
  &lt;li&gt;close: 当套接字完全关闭时，触发该事件。&lt;/li&gt;
  &lt;li&gt;timeout: 当一定事件后连接不再活跃时，该事件将会被触发，通知用户当前连接已经被闲置了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;TCP套接字是可写可读的Stream对象，可以利用pip()方法巧妙实现管道操作&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;udp&quot;&gt;UDP&lt;/h3&gt;

&lt;p&gt;在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下，存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如：音频、视频等等。DNS服务也是基于它实现的。&lt;/p&gt;

&lt;h4 id=&quot;创建udp套接字&quot;&gt;创建UDP套接字&lt;/h4&gt;

&lt;p&gt;一旦创建，既可以作为客户端发送数据，也可以作为服务器端接受数据。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dgram&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'dgram'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dgram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createScoket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'udp4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建服务器端：调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dgram.bing(port, [address])&lt;/code&gt; 设置网卡和端口&lt;/li&gt;
  &lt;li&gt;创建客户端，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;send()&lt;/code&gt;发送消息到网络中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;udp套接字事件&quot;&gt;UDP套接字事件&lt;/h4&gt;

&lt;p&gt;UDP套接字事件只是一个EventEmitter的实例，具备如下自定义事件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;message: 当UDP套接字侦听网卡端口后，接受到消息时触发该事件，触发携带的数据为消息的&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;对象和一个远程地址信息&lt;/li&gt;
  &lt;li&gt;listening: 当UDP套接字开始侦听时触发&lt;/li&gt;
  &lt;li&gt;close: 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt;方法时触发该事件，并不再触发&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件。如需再次触发&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件，可以重新绑定&lt;/li&gt;
  &lt;li&gt;error: 当异常发生时触发&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;构建http服务&quot;&gt;构建HTTP服务&lt;/h3&gt;

&lt;h4 id=&quot;http&quot;&gt;HTTP&lt;/h4&gt;

&lt;p&gt;从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。&lt;/p&gt;

&lt;p&gt;无论是HTTP请求报文还是HTTP响应报文，报文内容都包含两个部分：报文头和报文体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、TCP的3次握手&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Rebuilt URL to: www.baidu.com/
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;   Trying 220.181.111.188...
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; TCP_NODELAY &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Connected to www.baidu.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;220.181.111.188&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; port 80 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#0)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、客户端想服务器端发送请求报文&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; GET / HTTP/1.1
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Host: www.baidu.com
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; User-Agent: curl/7.54.0
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Accept: &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、服务器端完成处理后，向客户端发送响应内容，包括响应头和响应体&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: bfe/1.0.8.18
&amp;lt; Date: Thu, 03 Aug 2017 05:20:56 GMT
&amp;lt; Content-Type: text/html
&amp;lt; Content-Length: 2381
&amp;lt; Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT
&amp;lt; Connection: Keep-Alive
&amp;lt; ETag: &lt;span class=&quot;s2&quot;&gt;&quot;588604c8-94d&quot;&lt;/span&gt;
&amp;lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
&amp;lt; Pragma: no-cache
&amp;lt; Set-Cookie: &lt;span class=&quot;nv&quot;&gt;BDORZ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;27315&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; max-age&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;86400&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;.baidu.com&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/
&amp;lt; Accept-Ranges: bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、最后部分为结束会话的信息&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;http模块&quot;&gt;http模块&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;http模块即是将&lt;code class=&quot;highlighter-rouge&quot;&gt;connection&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;的过程进行了封装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/%60connection%60%E5%88%B0%60request%60%E7%9A%84%E8%BF%87%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85.png?raw=true&quot; alt=&quot;`connection`到`request`的过程进行封装&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除此之外，http模块将连接所用套接字的读写抽象为&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerRequest&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerResponse&lt;/code&gt;对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块&lt;code class=&quot;highlighter-rouge&quot;&gt;http_parser&lt;/code&gt;进行解析，解析完请求报文的报头后，触发&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;事件，调用用户业务逻辑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/http%E6%A8%A1%E5%9D%97%E4%BA%A7%E7%94%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true&quot; alt=&quot;http模块产生请求的流程&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;http请求&quot;&gt;http请求&lt;/h5&gt;

&lt;p&gt;请求报文头第一行&lt;code class=&quot;highlighter-rouge&quot;&gt;GET/HTTP/1.1&lt;/code&gt;解析分为如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;req.method属性： 值为GET,是为http请求方法&lt;/li&gt;
  &lt;li&gt;req.url属性：值为/&lt;/li&gt;
  &lt;li&gt;req.httpVersion属性，值为1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余报头很规律的&lt;code class=&quot;highlighter-rouge&quot;&gt;Key: Value&lt;/code&gt;格式，被解析后放置在&lt;code class=&quot;highlighter-rouge&quot;&gt;req.headers&lt;/code&gt;属性上传递给业务逻辑调用。
报文体部分则抽象为一个只读对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能操作。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;trunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;trunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'end'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Hello World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;http响应&quot;&gt;http响应&lt;/h5&gt;

&lt;p&gt;http响应封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部消息的API为&lt;code class=&quot;highlighter-rouge&quot;&gt;setHeader()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;writeHead()&lt;/code&gt;两个步骤，实际生成如下报文：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setHeader&lt;/code&gt;进行多次设置，但只有调用&lt;code class=&quot;highlighter-rouge&quot;&gt;writeHead&lt;/code&gt;后，报头才会被写入到连接中。
报文体部分则是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;res.write()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;res.end()&lt;/code&gt;方法实现，后者和前者的差别在于&lt;code class=&quot;highlighter-rouge&quot;&gt;res.end()&lt;/code&gt;会先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;发送数据，然后发送信号告知服务器这次响应结束。&lt;/p&gt;

&lt;h5 id=&quot;http服务的事件&quot;&gt;http服务的事件&lt;/h5&gt;

&lt;p&gt;服务器也是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EventEmitter&lt;/code&gt;实例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;connection事件&lt;/li&gt;
  &lt;li&gt;request事件&lt;/li&gt;
  &lt;li&gt;close事件&lt;/li&gt;
  &lt;li&gt;checkContinue事件&lt;/li&gt;
  &lt;li&gt;connect事件&lt;/li&gt;
  &lt;li&gt;upgrade事件&lt;/li&gt;
  &lt;li&gt;clientError事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http客户端&quot;&gt;http客户端&lt;/h4&gt;

&lt;p&gt;与http服务器基本相似，提供一个&lt;code class=&quot;highlighter-rouge&quot;&gt;http.request(options, connect)&lt;/code&gt; 用于构造HTTP客户端。&lt;/p&gt;

&lt;h5 id=&quot;options选项&quot;&gt;options选项&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;host: 服务器的域名或者IP地址, 默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;hostname: 服务器名称&lt;/li&gt;
  &lt;li&gt;port: 服务器端口&lt;/li&gt;
  &lt;li&gt;localAddress: 建立网络连接的本地网卡&lt;/li&gt;
  &lt;li&gt;socketPath: Domain套接字路径&lt;/li&gt;
  &lt;li&gt;method: HTTP请求方法，默认为GET&lt;/li&gt;
  &lt;li&gt;path: 请求路径，默认为/&lt;/li&gt;
  &lt;li&gt;headers: 请求头对象&lt;/li&gt;
  &lt;li&gt;auth: &lt;code class=&quot;highlighter-rouge&quot;&gt;Basic&lt;/code&gt;认证，这个值将被计算为请求头中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization&lt;/code&gt;部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;http响应-1&quot;&gt;http响应&lt;/h5&gt;

&lt;p&gt;HTTP客户端的响应对象与服务器相似，在&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRequest&lt;/code&gt;对象中，它的事件叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;http代理&quot;&gt;http代理&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;HTTP代理对服务器端创建的连接进行管理&lt;/strong&gt;
&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/master/%E7%A4%BA%E6%84%8F%E5%9B%BE/HTTP%E4%BB%A3%E7%90%86%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86.png?raw=true&quot; alt=&quot;HTTP代理对服务器端创建的连接进行管理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名下有下载连接数的限制是相同的行为。如需改变，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;option&lt;/code&gt;中传递&lt;code class=&quot;highlighter-rouge&quot;&gt;agent&lt;/code&gt;选项。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;构建webscoket服务&quot;&gt;构建WebScoket服务&lt;/h3&gt;

&lt;p&gt;WebScoket与传统HTTP有以下好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端与服务器端只建立一个TCP连接，可以使用更少的连接&lt;/li&gt;
  &lt;li&gt;WebScoket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活高效&lt;/li&gt;
  &lt;li&gt;有更轻量的协议头，减少数据传输&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebScoket协议主要分为两个部分：&lt;strong&gt;握手&lt;/strong&gt; 和 &lt;strong&gt;数据传输&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;网络服务与安全&quot;&gt;网络服务与安全&lt;/h3&gt;

&lt;p&gt;SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传输到应用层之前就已经完成了加密和解密的过程。最初的SSL应用在web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称为TLS(Transport Layer Security, 安全传输层协议)。&lt;/p&gt;

&lt;h4 id=&quot;tlsssl&quot;&gt;TLS/SSL&lt;/h4&gt;

&lt;p&gt;TLS/SSL是一个公钥/私钥的结构，是一个非堆成的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接受到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以建立连接安全传输之前，客户端和服务器端互换公钥。客户端发送数据时要通过服务器端的公钥加密，服务器端发送数据时则需要通过客户端的公钥进行加密。&lt;/p&gt;

&lt;p&gt;Node底层采用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;openssl&lt;/code&gt;实现的TLS/SSL,为此要生成公钥和私钥可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;openssl&lt;/code&gt;实现。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 服务器端私钥
openssl genrsa &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; server.key 1024

// 客户端私钥
openssl genrsa &lt;span class=&quot;nt&quot;&gt;--out&lt;/span&gt; client.key 1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是这样网络中依然可能存在窃听情况，典型的例子是中间人攻击。为了解决这个问题，引入了&lt;strong&gt;数字证书&lt;/strong&gt;。与直接公钥不同，数字证书中包含了服务器的名称和主机名，服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。&lt;/p&gt;

&lt;h4 id=&quot;https&quot;&gt;HTTPS&lt;/h4&gt;

&lt;p&gt;HTTPS服务就是工作在TLS/SSL上的HTTP。&lt;/p&gt;

&lt;p&gt;创建HTTPS服务如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;准备证书&lt;/li&gt;
  &lt;li&gt;创建HTTPS服务&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 02 Aug 2017 07:37:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/02/learn-node-06-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/02/learn-node-06-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 05 day</title>
        <description>&lt;h2 id=&quot;理解buffer&quot;&gt;理解Buffer&lt;/h2&gt;

&lt;h3 id=&quot;buffer对象&quot;&gt;Buffer对象&lt;/h3&gt;

&lt;p&gt;Buffer是一个像Array的对象，但它主要用于操作字节。
Buffer所占用的内存不是通过v8分配的，属于堆外内存。&lt;/p&gt;

&lt;p&gt;在编码中，中文字在uft-8编码下占3各元素，字母和半角标点符号占用1个元素。&lt;/p&gt;

&lt;h3 id=&quot;buffer内存分配&quot;&gt;Buffer内存分配&lt;/h3&gt;

&lt;p&gt;为了高效地使用申请来的内存，node采用了slab分配机制。slab是一种动态内存管理机制，最早诞生于SunOS操作系统中，目前在一些*nix操作系统中有广泛应用。slab就是申请一块申请好的固定大小的内存区域。&lt;/p&gt;

&lt;p&gt;slab三种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;full: 完全分配状态&lt;/li&gt;
  &lt;li&gt;partial: 部分分配状态&lt;/li&gt;
  &lt;li&gt;empty: 没有被分配状态&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;size 小于8kb即为小对象，大于为大对象。&lt;/p&gt;

&lt;h4 id=&quot;分配小buffer对象&quot;&gt;分配小Buffer对象&lt;/h4&gt;

&lt;p&gt;同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8kb空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是9kb的内存没有释放。&lt;/p&gt;

&lt;h4 id=&quot;分配大buffer对象&quot;&gt;分配大Buffer对象&lt;/h4&gt;

&lt;p&gt;如果需要超过8kb的Buffer对象，将会直接分配一个&lt;code class=&quot;highlighter-rouge&quot;&gt;SlowBuffer&lt;/code&gt;对象作为slab单元，这个slab单元将会被这个大Buffer对象独占。&lt;/p&gt;

&lt;h3 id=&quot;buffer的转换&quot;&gt;Buffer的转换&lt;/h3&gt;

&lt;p&gt;Buffer对象可以与字符串之间相互转换，目前支持类型如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ASCII&lt;/li&gt;
  &lt;li&gt;UTF-8&lt;/li&gt;
  &lt;li&gt;UTD-16LE/UCS-2&lt;/li&gt;
  &lt;li&gt;Base64&lt;/li&gt;
  &lt;li&gt;Binary&lt;/li&gt;
  &lt;li&gt;Hex&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//判断编码是否支持&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;字符串转buffer&quot;&gt;字符串转Buffer&lt;/h4&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个Buffer对象可以存储不同的编码类型的字符串转码的值，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;方法可以实现。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;由于可以不断写入内容到Buffer对象中并且每次写入可以指定编码，所以Buffer对象中可以存在多种编码转化后的内容。值得注意的是，每种编码所用的字节长度不一样，将Buffer反转回字符串时需要小心处理。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;buffer转字符串&quot;&gt;Buffer转字符串&lt;/h4&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//encoding默认为UTF-8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;buffer的拼接&quot;&gt;Buffer的拼接&lt;/h3&gt;

&lt;p&gt;Buffer的使用场景通常是以一段一段的方式传输。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这句代码隐藏了toString()操作，等价于:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样的方式在英文环境下不错有问题，但对于宽字节的中文就会出现乱字节问题。&lt;/p&gt;

&lt;h3 id=&quot;buffer与性能&quot;&gt;Buffer与性能&lt;/h3&gt;

&lt;p&gt;Buffer在文件I/O和网络I/O中运用广泛，尤其在网络传输中。在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为Buffer，以二进制数据传输。&lt;/p&gt;

&lt;p&gt;在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Aug 2017 07:13:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/01/learn-node-05-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/08/01/learn-node-05-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
      <item>
        <title>《深入浅出NodeJs》学习笔记 04 day</title>
        <description>&lt;h2 id=&quot;内存控制&quot;&gt;内存控制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;问题1：Node如何利用CPU和I/O这两个服务器资源？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题2：Node如何合理高效地是用内存?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一切都与Node的JavaScript执行引擎V8息息相关&lt;/p&gt;

&lt;h3 id=&quot;v8的内存限制&quot;&gt;V8的内存限制&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;64位系统下约为1.4GB&lt;/li&gt;
  &lt;li&gt;32位系统下约为0.7GB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么V8要限制堆的大小呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表层原因因为V8最初为浏览器而设计，不大可能遇到大量是用内存的场景。对于网页来说，V8的限制值已经足以应付。&lt;/li&gt;
  &lt;li&gt;深层的原因是V8的垃圾回收机制的限制。按照官方的说法，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至需要1秒以上。这是垃圾回收中引起的JavaScript线程暂停执行的时间，在这样的时间开销下，应用的性能和响应能力会直线下降。这样的情况不仅后端服务器无法接受，前端浏览器也无法接收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;v8的垃圾回收机制&quot;&gt;V8的垃圾回收机制&lt;/h3&gt;

&lt;h4 id=&quot;内存分代回收算法&quot;&gt;内存分代回收算法&lt;/h4&gt;

&lt;p&gt;在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/V8%E5%88%86%E4%BB%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;分代&quot; /&gt;&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;h4 id=&quot;新生代scavenge算法&quot;&gt;新生代：Scavenge算法&lt;/h4&gt;

&lt;p&gt;新生代中主要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;算法进行垃圾回收。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;算法实现中主要采用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Cheney&lt;/code&gt;算法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为&lt;code class=&quot;highlighter-rouge&quot;&gt;semispace&lt;/code&gt;。在这两个&lt;code class=&quot;highlighter-rouge&quot;&gt;semispace&lt;/code&gt;空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;semispace&lt;/code&gt;空间称为&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间，处于闲置状态的称为&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间。当我们分配对象时，先是在&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间中进行分配。当开始进行垃圾回收时，会检查&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间中存活的对象，这些存活的对象将被复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间中，而非存活对象占用的空间将会被释放。完成复制后，&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;空间和&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间进行互换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;缺点是只能使用堆内存的一般，这是由划分空间和复制机制所决定的。但是Scavenge只复制存活的对象，并且对于声明周期短的场景存活对象占很少部分，所以他在时间效率上有优异的表现，它是典型的牺牲空间换取时间的算法。所以在新生代中尤为合适。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/V8%E5%A0%86%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;新生代堆内存&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;当一个对象经过多次复制依然存户时，它将被认为是生命周期较长的对象。较长生命周期的对象随后会被移到老生代中，采用新的算法进行管理，这一过程称为&lt;code class=&quot;highlighter-rouge&quot;&gt;晋升&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;晋升条件主要有两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否经历过&lt;code class=&quot;highlighter-rouge&quot;&gt;Scavenge&lt;/code&gt;回收&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;To&lt;/code&gt;空间的内存占用比超过限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;老生代-mark-sweep--mark-compact算法&quot;&gt;老生代： Mark-Sweep &amp;amp; Mark-Compact算法&lt;/h4&gt;

&lt;p&gt;Mark-Sweep: 标记清除算法，它分为标记和清除两个阶段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/Mark-Sweep%E5%9C%A8%E8%80%81%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%A0%87%E8%AE%B0%E5%90%8E%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;Mark-Sweep&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Mark-Sweep&lt;/code&gt;会有一个最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态，碎片化。这时如果分配一个大对象时可能所有的碎片空间无法完成，就会提前触发垃圾回收机制，而这次回收是不必要的。&lt;/p&gt;

&lt;p&gt;所以为了解决这个问题，结合&lt;code class=&quot;highlighter-rouge&quot;&gt;Mark-Compact&lt;/code&gt;，标记整理对象标记死亡后的碎片化空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/peakcool/learn-nodejs-notes/blob/08958d35532ad8ea5fc78a3c2411f4fcc505ffa6/%E7%A4%BA%E6%84%8F%E5%9B%BE/Mark-Compact%E6%95%B4%E7%90%86%E7%A2%8E%E7%89%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true&quot; alt=&quot;Mark-Compact&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;三种垃圾回收算法简单对比&quot;&gt;三种垃圾回收算法简单对比&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回收算法&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Mark-Sweep&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Mark-Compact&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Scavenge&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;速度&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最慢&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;最快&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;空间开销&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;少（有碎片）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;少（有碎片）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;双倍空间（无碎片）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是否移动对象&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;科目标签设置&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;查看垃圾回收日志&quot;&gt;查看垃圾回收日志&lt;/h3&gt;

&lt;p&gt;启动时添加trace_gc参数，在进行垃圾回收时，将会从标准输出中打印垃圾回收日志&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node &lt;span class=&quot;nt&quot;&gt;--trace_gc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;var a = []; for(var i = 0; i &amp;lt; 1000000; i++) a.push(new Array(100));&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gc.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;高效使用内存&quot;&gt;高效使用内存&lt;/h3&gt;

&lt;h4 id=&quot;作用域&quot;&gt;作用域&lt;/h4&gt;

&lt;h5 id=&quot;1标志符查找&quot;&gt;1.标志符查找&lt;/h5&gt;

&lt;p&gt;与作用域相关的即是标志符查找。所谓标志符，可以理解为变量名。&lt;/p&gt;

&lt;h5 id=&quot;2作用域链&quot;&gt;2.作用域链&lt;/h5&gt;

&lt;p&gt;一直沿着作用域链查找到全局作用域，最后抛出未定义错误。&lt;/p&gt;

&lt;h5 id=&quot;3变量的主动释放&quot;&gt;3.变量的主动释放&lt;/h5&gt;

&lt;p&gt;如果变量是全局变量（不通过&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;声明或定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;变量上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存对象，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。&lt;/p&gt;

&lt;p&gt;虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;操作和重新赋值具有相同的效果，但是在V8中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好。&lt;/p&gt;

&lt;h4 id=&quot;闭包&quot;&gt;闭包&lt;/h4&gt;

&lt;p&gt;实现外部作用域访问内部作用域中变量的方法叫做闭包。&lt;/p&gt;

&lt;p&gt;闭包是JavaScript的高级特性，在使用内存时，它的问题在于：一旦有变量引用了这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域产生的内存占用也不会得到释放。除非不再引用，才会逐步释放。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内存指标&quot;&gt;内存指标&lt;/h3&gt;

&lt;h4 id=&quot;内存使用情况&quot;&gt;内存使用情况&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;查看进程内存占用 &lt;code class=&quot;highlighter-rouge&quot;&gt;process.memoryUsage()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;os模块查看操作系统内存使用情况 &lt;code class=&quot;highlighter-rouge&quot;&gt;totalmem()&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;freemem()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;堆外内存&quot;&gt;堆外内存&lt;/h4&gt;

&lt;p&gt;不是通过V8分配的内存称为&lt;strong&gt;堆外内存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node的内存构成主要通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内存泄露&quot;&gt;内存泄露&lt;/h3&gt;

&lt;p&gt;通常造成内存泄露的原因：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;缓存&lt;/li&gt;
  &lt;li&gt;队列消费不及时&lt;/li&gt;
  &lt;li&gt;作用域未释放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript创建一个缓存对象&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// get from ohterwise&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;慎将内存做缓存&quot;&gt;慎将内存做缓存&lt;/h4&gt;

&lt;p&gt;缓存限制策略：限制键值数量，大小&lt;/p&gt;

&lt;p&gt;目前比较好的解决方案是采用进程外的缓存，进程本身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自身的内存管理，不影响Node进程的性能。&lt;/p&gt;

&lt;p&gt;在Node中主要可以解决一下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效&lt;/li&gt;
  &lt;li&gt;进程之间可以共享缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前推荐: &lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Memcached&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;关注队列状态&quot;&gt;关注队列状态&lt;/h4&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;消费速度 &amp;gt; 生产速度 = 正常&lt;/li&gt;
  &lt;li&gt;消费速度 &amp;lt; 生产速度 = 不正常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在队列实现时，优化代码的同时也要考虑到监控队列的长度，一旦消费速度小于生产速度，堆积对象过多时，应当通过系统产生报警并通知；或者任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个限定值。&lt;/p&gt;

&lt;h3 id=&quot;内存排查&quot;&gt;内存排查&lt;/h3&gt;

&lt;p&gt;常见工具&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;v8-profiler&lt;/li&gt;
  &lt;li&gt;node-heapdump&lt;/li&gt;
  &lt;li&gt;node-mtrace&lt;/li&gt;
  &lt;li&gt;dtrace&lt;/li&gt;
  &lt;li&gt;node-memwatch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般通过对堆内存进行分析而找到泄露原因。&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Jul 2017 21:33:00 +0800</pubDate>
        <link>http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/25/learn-node-04-day.html</link>
        <guid isPermaLink="true">http://peakcool.cn/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/2017/07/25/learn-node-04-day.html</guid>
        
        
        <category>技术分享</category>
        
      </item>
    
  </channel>
</rss>
